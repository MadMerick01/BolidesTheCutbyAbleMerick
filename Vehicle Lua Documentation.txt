Vehicle Lua Documentation (based on ETK 800)
Expand All Collapse All

object
{186}
BeamEngine
{19}
deleteAllObjects(*)
[1]
0
:
BeamEngine:deleteAllObjects()
directoryExists(*)
:
[object Object]
fileExists(*)
:
[object Object]
findFiles(*)
:
[object Object]
getEnabled(*)
:
[object Object]
getGroundModelByName(*)
:
[object Object]
getSimulationTimeScale(*)
:
[object Object]
getSlot(*)
:
[object Object]
getSlotCount(*)
[3]
0
:
if BeamEngine:getSlotCount() ~= n then
1
:
print ("error: " .. BeamEngine:getSlotCount() .. " vehicles spawned of " .. n .. " requested")
2
:
if BeamEngine:getSlotCount() > 1 then -- only player vehicle exists
instabilityDetected(*)
:
[object Object]
queueAllObjectLua(*)
[2]
0
:
BeamEngine:queueAllObjectLua("beamstate.setCouplerVisiblityExternal(" .. tostring(obj:getID()) .. "," .. tostring(visible) .. ")")
1
:
BeamEngine:queueAllObjectLua('ai.setMode("stop")')
queueAllObjectLuaExcept(*)
[3]
0
:
BeamEngine:queueAllObjectLuaExcept('ai.setSpeedMode("off")', objectId)
1
:
BeamEngine:queueAllObjectLuaExcept('ai.driveInLane("off")', objectId)
2
:
BeamEngine:queueAllObjectLuaExcept('ai.setState({mode = "random", extAggression = 1, targetObjectID = '..tostring(objectId)..'})', objectId)
resetGroundModels(*)
:
[object Object]
setDynamicCollisionEnabled(*)
:
[object Object]
setEnabled(*)
:
[object Object]
setGroundModelByName(*)
:
[object Object]
setSimulationTimeScale(*)
:
[object Object]
spawnObject(*)
[1]
0
:
BeamEngine:spawnObject("vehicles/"..v, nil, float3(0, 3 * n, 0)) -- this assumes that the object is max. 3 meters high
update(*)
[2]
0
:
BeamEngine:update(1/2000, 1/2000)
1
:
BeamEngine:update(1/2000, 1/2000)
FILTER_DIRECT
[3]
0
:
FILTER_DIRECT = 2
1
:
if e.filter == FILTER_DIRECT then
2
:
for i,v in ipairs({ FILTER_KBD, FILTER_PAD, FILTER_DIRECT, FILTER_KBD2 }) do
FILTER_KBD
[3]
0
:
FILTER_KBD = 0
1
:
FILTER_KBD2 = 3
2
:
elseif e.filter == FILTER_KBD then
FILTER_KBD2
[3]
0
:
FILTER_KBD2 = 3
1
:
elseif e.filter == FILTER_KBD2 then
2
:
for i,v in ipairs({ FILTER_KBD, FILTER_PAD, FILTER_DIRECT, FILTER_KBD2 }) do
FILTER_PAD
[3]
0
:
FILTER_PAD = 1
1
:
if e.filter == FILTER_PAD then -- joystick / game controller - smoothing without autocentering
2
:
for i,v in ipairs({ FILTER_KBD, FILTER_PAD, FILTER_DIRECT, FILTER_KBD2 }) do
FS
{19}
deleteAllObjects(*)
:
[object Object]
directoryExists(*)
:
[object Object]
fileExists(*)
[3]
0
:
if FS:fileExists(file) then
1
:
if not FS:fileExists(fn) then
2
:
if not FS:fileExists(file) then
findFiles(*)
[3]
0
:
local files = FS:findFiles(directory, "*.lua", -1, true, false)
1
:
local luaFiles = FS:findFiles(directory, '*.lua', -1, true, false)
2
:
local filePaths = FS:findFiles(directory, "*.lua", -1, true, false)
getEnabled(*)
:
[object Object]
getGroundModelByName(*)
:
[object Object]
getSimulationTimeScale(*)
:
[object Object]
getSlot(*)
:
[object Object]
getSlotCount(*)
:
[object Object]
instabilityDetected(*)
:
[object Object]
queueAllObjectLua(*)
:
[object Object]
queueAllObjectLuaExcept(*)
:
[object Object]
resetGroundModels(*)
:
[object Object]
setDynamicCollisionEnabled(*)
:
[object Object]
setEnabled(*)
:
[object Object]
setGroundModelByName(*)
:
[object Object]
setSimulationTimeScale(*)
:
[object Object]
spawnObject(*)
:
[object Object]
update(*)
:
[object Object]
HighPerfTimer
{1}
getTime(*)
:
[object Object]
Lua
{3}
enableStackTraceFile(*)
:
[object Object]
exec(*)
:
[object Object]
log(*)
[2]
0
:
Lua:log(...)
1
:
Lua:log("A", "print", tostring(...))
RESET_PHYSICS
[3]
0
:
obj:requestReset(RESET_PHYSICS)
1
:
obj:requestReset(RESET_PHYSICS) -- fix vehicle + reset velocity
2
:
obj:requestReset(RESET_PHYSICS)
ai
{37}
avoidCarsMaster
:
[object Object]
cutOffDrivability
:
[object Object]
debugMode
[1]
0
:
scriptai.debugMode = mode
extAggression
:
[object Object]
mode
:
[object Object]
targetObjectID
:
[object Object]
debugDraw()
[2]
0
:
scriptai.debugDraw()
1
:
ai.debugDraw(focusPos)
driveInLane(v)
[3]
0
:
BeamEngine:queueAllObjectLuaExcept('ai.driveInLane("off")', objectId)
1
:
BeamEngine:queueAllObjectLuaExcept('ai.driveInLane("off")', objectId)
2
:
BeamEngine:queueAllObjectLuaExcept('ai.driveInLane("off")', objectId)
driveUsingPath(arg)
:
[object Object]
dumpCurrentRoute()
:
[object Object]
getState()
:
[object Object]
isDriving()
[3]
0
:
if ai.isDriving() then
1
:
if playerInfo.anyPlayerSeated and not ai.isDriving() then
2
:
if (not playerInfo.anyPlayerSeated) and ai.isDriving() and volume > 0 then return
onDeserialized(v)
:
[object Object]
reset()
[1]
0
:
ai.reset()
resetLearning()
:
[object Object]
scriptState()
[1]
0
:
return scriptai.scriptState()
scriptStop()
[1]
0
:
scriptai.scriptStop(...)
setAggression(v)
:
[object Object]
setAggressionMode(aggrmode)
:
[object Object]
setAvoidCars(v)
:
[object Object]
setCutOffDrivability(drivability)
:
[object Object]
setMode(mode)
[1]
0
:
BeamEngine:queueAllObjectLua('ai.setMode("stop")')
setPath(path)
:
[object Object]
setScriptDebugMode(mode)
:
[object Object]
setSpeed(speed)
:
[object Object]
setSpeedMode(speedMode)
[3]
0
:
BeamEngine:queueAllObjectLuaExcept('ai.setSpeedMode("off")', objectId)
1
:
BeamEngine:queueAllObjectLuaExcept('ai.setSpeedMode("off")', objectId)
2
:
BeamEngine:queueAllObjectLuaExcept('ai.setSpeedMode("off")', objectId)
setState(newState)
[3]
0
:
BeamEngine:queueAllObjectLuaExcept('ai.setState({mode = "random", extAggression = 1, targetObjectID = '..tostring(objectId)..'})', objectId)
1
:
BeamEngine:queueAllObjectLuaExcept('ai.setState({mode = "flee", extAggression = 1, targetObjectID = '..tostring(objectId)..'})', objectId)
2
:
BeamEngine:queueAllObjectLuaExcept('ai.setState({mode = "chase", extAggression = 1, targetObjectID = '..tostring(objectId)..'})', objectId)
setTarget(wp)
:
[object Object]
setTargetObjectID(id)
:
[object Object]
setVehicleDebugMode(newMode)
:
[object Object]
spanMap(cutOffDrivability)
:
[object Object]
startFollowing()
[1]
0
:
scriptai.startFollowing(...)
startRecording()
[1]
0
:
scriptai.startRecording()
stateChanged()
[1]
0
:
ai.stateChanged()
stopFollowing()
[1]
0
:
ai.stopFollowing()
stopRecording()
[1]
0
:
local script = scriptai.stopRecording()
updateGFX()
[1]
0
:
ai.updateGFX(dtSim) -- must be before input and after wheels
backwardsCompatibility
{2}
createCompatibilityPowertrain()
[1]
0
:
local result = backwardsCompatibility.createCompatibilityPowertrain()
init()
[1]
0
:
backwardsCompatibility.init()
bdebug
{24}
enableNodeSelection
:
[object Object]
loaded
:
[object Object]
origState
{6}
fov
:
[object Object]
physicsEnabled
:
[object Object]
renderer
{5}
boundingboxes
:
[object Object]
disableShadows
:
[object Object]
showFps
:
[object Object]
visualization
:
[object Object]
wireframe
:
[object Object]
terrain
{2}
groundmodel
:
[object Object]
staticCollision
:
[object Object]
vehicle
{16}
aero
:
[object Object]
aero_modes
:
[object Object]
aerodynamicsScale
:
[object Object]
beamVis
:
[object Object]
beamVisAlpha
:
[object Object]
beamVis_modes
:
[object Object]
cog
:
[object Object]
cog_modes
:
[object Object]
collisionTriangle
:
[object Object]
meshVisibility
:
[object Object]
nodeText
:
[object Object]
nodeText_modes
:
[object Object]
nodeVis
:
[object Object]
nodeVis_modes
:
[object Object]
objectData
:
[object Object]
tireContactPoint
:
[object Object]
vehicleDebugVisible
:
[object Object]
state
{6}
fov
:
[object Object]
physicsEnabled
:
[object Object]
renderer
{5}
boundingboxes
:
[object Object]
disableShadows
:
[object Object]
showFps
:
[object Object]
visualization
:
[object Object]
wireframe
:
[object Object]
terrain
{2}
groundmodel
:
[object Object]
staticCollision
:
[object Object]
vehicle
{16}
aero
:
[object Object]
aero_modes
:
[object Object]
aerodynamicsScale
:
[object Object]
beamVis
:
[object Object]
beamVisAlpha
:
[object Object]
beamVis_modes
:
[object Object]
cog
:
[object Object]
cog_modes
:
[object Object]
collisionTriangle
:
[object Object]
meshVisibility
:
[object Object]
nodeText
:
[object Object]
nodeText_modes
:
[object Object]
nodeVis
:
[object Object]
nodeVis_modes
:
[object Object]
objectData
:
[object Object]
tireContactPoint
:
[object Object]
vehicleDebugVisible
:
[object Object]
activated(m)
[1]
0
:
bdebug.activated(playerInfo.anyPlayerSeated)
beamBroke()
[1]
0
:
bdebug.beamBroke(id, energy)
beamDeformed()
[1]
0
:
bdebug.beamDeformed(id, ratio)
cogChange(change)
:
[object Object]
debugDraw()
[1]
0
:
bdebug.debugDraw(focusPos)
debugDrawNode(col, node, txt)
:
[object Object]
init()
[2]
0
:
--log('D', "lua","bdebug.init()")
1
:
bdebug.init()
meshVisChange(val, isAbsoluteValue)
:
[object Object]
nodeCollision()
[1]
0
:
bdebug.nodeCollision(p)
nodetextModeChange(change)
:
[object Object]
nodevisModeChange(change)
:
[object Object]
onDeserialized()
[1]
0
:
--log('D', "lua","bdebug.onDeserialized()")
requestState()
:
[object Object]
reset()
[2]
0
:
--log('D', "lua","bdebug.reset()")
1
:
bdebug.reset()
resetModes()
:
[object Object]
selectNode()
:
[object Object]
setState(state)
:
[object Object]
skeletonModeChange(change)
:
[object Object]
toggleColTris()
:
[object Object]
toggleEnabled()
:
[object Object]
beamstate
{47}
damage
[2]
0
:
obj:queueGameEngineLua(stringFormat('map.objectData(%s,%s,%s,%s,{%s})', objectId, anyPlayerSeated, math.floor(beamstate.damage), next(states) and serialize(states) or 'nil', table.concat(serTmp, ',')))
1
:
obj:queueGameEngineLua(stringFormat('map.objectData(%s,%s,%s,%s)', objectId, anyPlayerSeated, math.floor(beamstate.damage), next(states) and serialize(states) or 'nil'))
damageExt
:
[object Object]
deformGroupDamage
{35}
differential_F
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
differential_R
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
display_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
doorglass_FL_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
doorglass_FR_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
doorglass_RL_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
doorglass_RR_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
driveshaft
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
driveshaft_F
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
fendersignal_L_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
fendersignal_R_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
foglightglass_L_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
foglightglass_R_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
frontflashers_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
headlightglass_L_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
headlightglass_R_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
mainEngine
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
mainEngine_accessories
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
mainEngine_intake
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
oilpan_damage
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
radiator_damage
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
radtube_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
sideglass_L_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
sideglass_R_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
sunroof_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
tailgateglass_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
tailgatelight_L_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
tailgatelight_R_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
taillightglass_L_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
taillightglass_R_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
wheelaxleFL
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
wheelaxleFR
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
wheelaxleRL
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
wheelaxleRR
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
windshield_break
{4}
damage
:
[object Object]
eventCount
:
[object Object]
invMaxEvents
:
[object Object]
maxEvents
:
[object Object]
lowpressure
[1]
0
:
vals.lowpressure = (beamstate.lowpressure)
monetaryDamage
:
[object Object]
activateAutoCoupling(_nodetag)
:
[object Object]
addDamage(damage)
[1]
0
:
beamstate.addDamage(500)
addPlanet(center, radius, mass, dt)
:
[object Object]
attachCouplers(_nodetag)
:
[object Object]
beamBroken(id, energy)
[1]
0
:
beamstate.beamBroken(id, energy)
beamDeformed(id, ratio)
[1]
0
:
beamstate.beamDeformed(id, ratio)
breakAllBreakgroups()
:
[object Object]
breakBreakGroup(g)
:
[object Object]
breakHinges()
:
[object Object]
couplerExists(_nodetag)
:
[object Object]
couplerFound(nodeId, obj2id, obj2nodeId)
[1]
0
:
beamstate.couplerFound(nodeId, obj2id, obj2nodeId)
debugDraw()
[1]
0
:
beamstate.debugDraw(focusPos)
deflateTire(wheelid)
[1]
0
:
beamstate.deflateTire(wheelData.wheelID, 1)
deflateTires()
:
[object Object]
delPlanet(center, radius, mass)
:
[object Object]
detachCouplers(_nodetag, forceLocked, forceWelded)
:
[object Object]
disableAutoCoupling()
:
[object Object]
exportCouplerData(nodeid, dataList)
[2]
0
:
--print("couplerAttached -> beamstate.exportCouplerData("..tostring(obj2nodeId)..", "..serialize(data)..")")
1
:
obj:queueObjectLuaCommand(obj2id, "beamstate.exportCouplerData(" .. tostring(obj2nodeId) .. ", " .. serialize(data) .. ")")
exportPartDamageData()
:
[object Object]
getCouplerOffset(callback)
:
[object Object]
getPartCondition(partName, partTypeData)
[1]
0
:
local jbeamCondition, omitSpawn, canProvideBeamstateCondition = beamstate.getPartCondition(partName, partData)
getPartDamageData()
:
[object Object]
getVehicleState()
:
[object Object]
hasCouplers()
[1]
0
:
if beamstate.hasCouplers() then
importCouplerData(nodeId, data)
[1]
0
:
obj:queueObjectLuaCommand(coupler.obj2id, string.format("beamstate.importCouplerData(%s, %s)", coupler.obj2nodeId, serialize(data)))
init()
[1]
0
:
beamstate.init()
isPhysicsStepUsed()
:
[object Object]
load(filename)
[1]
0
:
beamstate.load()
onCouplerAttached(nodeId, obj2id, obj2nodeId)
[1]
0
:
beamstate.onCouplerAttached(nodeId, obj2id, obj2nodeId)
onCouplerDetached(nodeId, obj2id, obj2nodeId)
[1]
0
:
beamstate.onCouplerDetached(nodeId, obj2id, obj2nodeId)
requestSkeleton()
:
[object Object]
requestSkeletonState()
:
[object Object]
reset()
[1]
0
:
beamstate.reset()
save(filename)
:
[object Object]
setCouplerVisiblityExternal(sourceObjectID, visible)
[1]
0
:
BeamEngine:queueAllObjectLua("beamstate.setCouplerVisiblityExternal(" .. tostring(obj:getID()) .. "," .. tostring(visible) .. ")")
setPartCondition(partName, partTypeData, odometer, integrity, visual)
[1]
0
:
beamstate.setPartCondition(partName, partTypes, odometer, integrity, visual)
setPlanets(p)
:
[object Object]
toggleCouplers()
:
[object Object]
triggerDeformGroup(group)
:
[object Object]
update(dtSim)
[1]
0
:
beamstate.update(dtSim)
updateGFX(dt)
[1]
0
:
beamstate.updateGFX(dtSim) -- must be after drivetrain
updateRemoteElectrics()
[1]
0
:
beamstate.updateRemoteElectrics()
bit
{12}
arshift(*)
:
[object Object]
band(*)
:
[object Object]
bnot(*)
:
[object Object]
bor(*)
[3]
0
:
o.dashLights = bit.bor(o.dashLights, DL_FULLBEAM)
1
:
o.showLights = bit.bor(o.showLights, DL_FULLBEAM)
2
:
o.dashLights = bit.bor(o.dashLights, DL_HANDBRAKE)
bswap(*)
:
[object Object]
bxor(*)
[3]
0
:
escPulse = escActive and bit.bxor(escPulse, 1) or 0
1
:
tcsPulse = tcsActive and bit.bxor(tcsPulse, 1) or 0
2
:
absPulse = absActive and bit.bxor(absPulse, 1) or 0
lshift(*)
:
[object Object]
rol(*)
:
[object Object]
ror(*)
:
[object Object]
rshift(*)
:
[object Object]
tobit(*)
:
[object Object]
tohex(*)
:
[object Object]
bullettime
{7}
get()
[1]
0
:
log('E', 'bullettime', 'bullettime.simulationSpeed API is deprecated. Please use bullettime.get()')
requestValue()
[1]
0
:
obj:queueGameEngineLua('bullettime.requestValue()')
reset()
:
[object Object]
selectPreset(v)
[1]
0
:
obj:queueGameEngineLua('bullettime.selectPreset('..dumps(v)..')')
set(v)
[1]
0
:
obj:queueGameEngineLua('bullettime.set('..tostring(1/v)..')')
slowMotion()
:
[object Object]
update()
:
[object Object]
controller
{33}
isFrozen
[1]
0
:
if not controller.isFrozen and aiSpeed < 0.1 and targetSpeed > 0.5 and (lastCommand.throttle ~= 0 or lastCommand.brake ~= 0) then
mainController
{30}
brake
:
[object Object]
clutchRatio
:
[object Object]
defaultOrder
:
[object Object]
engineInfo
:
[object Object]
fireEngineTemperature
[1]
0
:
currentNode.baseTemp = currentNode.useThermalsBaseTemp and controller.mainController.fireEngineTemperature or currentNode.staticBaseTemp
name
:
[object Object]
order
:
[object Object]
throttle
:
[object Object]
type
:
[object Object]
typeName
:
[object Object]
cycleGearboxModes()
:
[object Object]
init(jbeamData)
:
[object Object]
initLastStage()
:
[object Object]
onDeserialize(data)
:
[object Object]
onSerialize()
:
[object Object]
resetLastStage()
:
[object Object]
sendTorqueData()
[1]
0
:
controller.mainController.sendTorqueData()
setAggressionOverride(aggression)
:
[object Object]
setDefaultForwardMode(mode)
[1]
0
:
controller.mainController.setDefaultForwardMode(mode)
setEngineIgnition(enabled)
[1]
0
:
if controller.mainController.setEngineIgnition ~= nil then controller.mainController.setEngineIgnition( false )
setFreeze(mode)
[3]
0
:
controller.mainController.setFreeze(0)
1
:
controller.mainController.setFreeze(1)
2
:
controller.mainController.setFreeze(0)
setGearboxMode(behavior)
[3]
0
:
controller.mainController.setGearboxMode("arcade")
1
:
controller.mainController.setGearboxMode(mode)
2
:
controller.mainController.setGearboxMode("arcade")
setStarter(enabled)
[2]
0
:
controller.mainController.setStarter( false )
1
:
controller.mainController.setStarter( true )
settingsChanged(noRefresh)
:
[object Object]
shiftDown()
:
[object Object]
shiftToGearIndex(index)
[1]
0
:
controller.mainController.shiftToGearIndex(gear)
shiftUp()
:
[object Object]
smartParkingBrake(ivalue, filter)
:
[object Object]
updateGFX(dt)
:
[object Object]
vehicleActivated()
[1]
0
:
controller.mainController.vehicleActivated()
beamBroke()
[1]
0
:
controller.beamBroke(id, energy)
beamDeformed()
[1]
0
:
controller.beamDeformed(id, ratio)
cacheAllControllerFunctions()
:
[object Object]
debugDraw()
[1]
0
:
controller.debugDraw(focusPos)
debugUpdateList()
:
[object Object]
getAllControllers(name)
:
[object Object]
getController(name)
[3]
0
:
controller.getController(name).set4WDMode("connected")
1
:
controller.getController(name).set4WDMode("disconnected")
2
:
controller.getController(name).setRangeMode("high")
getControllerSafe(name)
[3]
0
:
--Using controller.getControllerSafe() instead returns a magic table that
1
:
controller.getControllerSafe("driveModes").nextDriveMode()
2
:
controller.getControllerSafe("vehicleController").setAggressionOverride(1)
getControllersByType(typeName)
[3]
0
:
for _, v in pairs(controller.getControllersByType("4wd")) do
1
:
for _, v in pairs(controller.getControllersByType("4wd")) do
2
:
local CMUControllers = controller.getControllersByType("drivingDynamics/CMU")
getControllersFromPath(path)
[3]
0
:
subControllers = controller.getControllersFromPath("drivingDynamics/")
1
:
subControllers = controller.getControllersFromPath("drivingDynamics/")
2
:
subControllers = controller.getControllersFromPath("drivingDynamics/")
init()
[3]
0
:
controller.init(data)
1
:
controller.init()
2
:
controller.init() -- needs to go after input first stage
initLastStage()
[1]
0
:
controller.initLastStage() --meant to be last in init
initSecondStage()
[1]
0
:
controller.initSecondStage()
initSounds()
[1]
0
:
controller.initSounds()
isPhysicsStepUsed()
:
[object Object]
nodeCollision()
[1]
0
:
controller.nodeCollision(p)
onCouplerAttached()
[1]
0
:
controller.onCouplerAttached(nodeId, obj2id, obj2nodeId)
onCouplerDetached()
[1]
0
:
controller.onCouplerDetached(nodeId, obj2id, obj2nodeId)
onCouplerFound()
[1]
0
:
controller.onCouplerFound(nodeId, obj2id, obj2nodeId)
onDeserialize(data)
:
[object Object]
onGameplayEvent()
:
[object Object]
onSerialize()
:
[object Object]
reset()
[1]
0
:
controller.reset()
resetLastStage()
[1]
0
:
controller.resetLastStage() --meant to be last in reset
resetSecondStage()
[1]
0
:
controller.resetSecondStage()
resetSounds()
[1]
0
:
controller.resetSounds()
setFreeze(mode)
[2]
0
:
log("W", "controller", "scenario.freeze(mode) is deprecated. Please switch to controller.setFreeze(mode)")
1
:
controller.setFreeze(freeze and 1 or 0)
settingsChanged()
[1]
0
:
controller.settingsChanged()
update(dt)
[1]
0
:
controller.update(dtSim)
updateGFX(dt)
[1]
0
:
controller.updateGFX(dtSim)
updateWheelsIntermediate(dt)
[1]
0
:
controller.updateWheelsIntermediate(dtSim)
core_performance
{5}
onExtensionLoaded()
:
[object Object]
popEvent()
[3]
0
:
core_performance.popEvent() -- 3.1 init - compat
1
:
core_performance.popEvent() -- 3.2.X init - materials (sum)
2
:
core_performance.popEvent() -- 3.2 init - first stage
printReport()
[1]
0
:
--core_performance.printReport()
pushEvent(label)
[3]
0
:
core_performance.pushEvent("lua init")
1
:
core_performance.pushEvent("3.1 init - compat")
2
:
core_performance.pushEvent("3.2.X init - materials (sum)")
saveReportToCSV(filename)
:
[object Object]
core_quickAccess
{5}
addEntry(_args)
[3]
0
:
core_quickAccess.addEntry(
1
:
core_quickAccess.addEntry(
2
:
core_quickAccess.addEntry(
onExtensionLoaded()
:
[object Object]
registerMenu()
:
[object Object]
requestItems(level)
:
[object Object]
selectItem(id)
:
[object Object]
coroutine
{7}
create(*)
[3]
0
:
local co = coroutine.create(handler)
1
:
local co = coroutine.create(handler)
2
:
coroutine.create(
isyieldable(*)
:
[object Object]
resume(*)
[3]
0
:
-- coroutine.resume((heap:pop())) -- assumes payload to be a coroutine,
1
:
local ok, res, new_q = coroutine.resume(co, skt, ...)
2
:
local errorfree, value = coroutine.resume(workerCoroutine)
running(*)
[3]
0
:
local co = coroutine.running()
1
:
operation_register[coroutine.running()] = queue
2
:
return timeout_flags[coroutine.running()]
status(*)
[2]
0
:
if coroutine.status(workerCoroutine) == "dead" then
1
:
if coroutine.status(workerCoroutine) == "dead" then
wrap(*)
:
[object Object]
yield(*)
[3]
0
:
coroutine.yield(client, _writing)
1
:
coroutine.yield(client, _reading)
2
:
coroutine.yield(client, _reading)
damageTracker
{8}
getDamage(group, name)
[3]
0
:
if lockupChance <= device.overRevDamage and not damageTracker.getDamage("engine", "catastrophicOverrevDamage") then
1
:
if device.overTorqueDamage >= device.maxOverTorqueDamage and not damageTracker.getDamage("engine", "catastrophicOverTorqueDamage") then
2
:
elseif damageTracker.getDamage("engine", "oilHot", true) then
init()
[1]
0
:
damageTracker.init()
registerDamageUpdateCallback(callback)
:
[object Object]
reset()
[1]
0
:
damageTracker.reset()
sendNow()
[1]
0
:
damageTracker.sendNow() --send over damage data of (now) active vehicle
setDamage(group, name, value, notifyUI)
[3]
0
:
damageTracker.setDamage("wheels", "tire" .. wheel.name, true)
1
:
damageTracker.setDamage("body", bodyPart, damage)
2
:
damageTracker.setDamage("body", k, 0)
updateGFX(dt)
[1]
0
:
damageTracker.updateGFX(dtSim)
willSend()
[1]
0
:
local updateDamage = damageTracker.willSend()
debug
{17}
debug(*)
:
[object Object]
getfenv(*)
:
[object Object]
gethook(*)
:
[object Object]
getinfo(*)
[3]
0
:
local s1 = debug.getinfo(2)
1
:
local s2 = debug.getinfo(3)
2
:
local s = debug.getinfo(2)
getlocal(*)
[3]
0
:
local ln, lv = debug.getlocal(2, idx)
1
:
local param = debug.getlocal( func, 1 )
2
:
param = debug.getlocal( func, index )
getmetatable(*)
:
[object Object]
getregistry(*)
:
[object Object]
getupvalue(*)
[3]
0
:
local name, upv = debug.getupvalue(func, i)
1
:
local name, value = debug.getupvalue(info.func, i)
2
:
local name, value = debug.getupvalue(var, i)
setfenv(*)
:
[object Object]
sethook(*)
[3]
0
:
debug.sethook(trace, "c")
1
:
debug.sethook()
2
:
debug.sethook(trace, "cr")
setlocal(*)
:
[object Object]
setmetatable(*)
:
[object Object]
setupvalue(*)
:
[object Object]
traceback(thread, message, level, level_limit, dump_locals)
[3]
0
:
log("E","", "An obsolete mod is using a deprecated API. See traceback below for more information:\n"..debug.traceback())
1
:
log("E", "controller.init", debug.traceback())
2
:
msg = debug.traceback(co, msg)
tracesimple(thread, message, level, level_limit, dump_locals)
[3]
0
:
--print("Unloading "..vmType.." extension: "..dumps(extName, extPath).."\n"..debug.tracesimple())
1
:
--print("Loading "..vmType.." extension: "..dumps(extName, extPath).."\n"..debug.tracesimple())
2
:
print(debug.tracesimple())
upvalueid(*)
:
[object Object]
upvaluejoin(*)
:
[object Object]
drivetrain
{24}
avgAV
:
[object Object]
brake
:
[object Object]
engineAV
:
[object Object]
engineDisabled
[1]
0
:
local minTemp = (drivetrain.engineDisabled or underWater == 1) and tEnv or max(tEnv, currentNode.baseTemp)
engineLoad
:
[object Object]
esc
{5}
escPulse
:
[object Object]
getCarData()
:
[object Object]
toggleESCMode()
:
[object Object]
update()
:
[object Object]
updateGFX()
:
[object Object]
fuel
:
[object Object]
fuelCapacity
:
[object Object]
fuelLeakRate
:
[object Object]
fuelUsage
:
[object Object]
gear
[1]
0
:
return sourcename == "gear" and drivetrain.gear or electrics.values[sourcename]
rpm
[1]
0
:
local rpm = drivetrain.rpm
shifterMode
[3]
0
:
return "vehicle.drivetrain.shifterModeNameArcade"
1
:
return "vehicle.drivetrain.shifterModeNameRealistic"
2
:
return "vehicle.drivetrain.shifterModeNameUnknown"
shifterPosition
:
[object Object]
throttle
:
[object Object]
torque
[1]
0
:
table.insert(torqueUpdateTable, "transmissionInputDevice.parent.outputTorque0 = drivetrain.torqueTransmission")
torqueTransmission
[1]
0
:
table.insert(torqueUpdateTable, "transmissionInputDevice.parent.outputTorque0 = drivetrain.torqueTransmission")
wheelCount
:
[object Object]
wheels
:
[object Object]
init()
[1]
0
:
drivetrain.init()
reset()
[1]
0
:
drivetrain.reset()
setShifterMode(v)
:
[object Object]
shiftToGear(gear)
:
[object Object]
updateGFX()
[1]
0
:
drivetrain.updateGFX(dtSim)
electrics
{16}
values
{70}
abs
[3]
0
:
local absActive = absActiveSmoother:getUncapped(electrics.values.absActive or 0, dt)
1
:
if electrics.values.abs ~= 0 then
2
:
gaugeData.electrics.abs = electrics.values.abs
absActive
[2]
0
:
local absActive = absActiveSmoother:getUncapped(electrics.values.absActive or 0, dt)
1
:
gaugeData.electrics.absActive = electrics.values.absActive
airflowspeed
[3]
0
:
electrics.values.airflowspeed or 0,
1
:
local airSpeed = electrics.values.airflowspeed
2
:
local airSpeed = electrics.values.airflowspeed
airspeed
[3]
0
:
local speed = electrics.values.airspeed * 3.6
1
:
local particleAirspeed = electrics.values.airspeed
2
:
local particleAirspeed = electrics.values.airspeed
altitude
:
[object Object]
avgWheelAV
[3]
0
:
local accSign = wheelspeed > 2 and fsign(electrics.values.avgWheelAV) or lastAccSign
1
:
electrics.values.avgWheelAV = 0
2
:
electrics.values.avgWheelAV = 0
brake
[3]
0
:
local brakeValue = min(electrics.values.brake + escBrakeValue, 1)
1
:
electrics.values.brake = math.min(math.max(input.brake or 0, 0), 1)
2
:
if diffSideToBrake ~= 0 and electrics.values.throttle > 0 and electrics.values.brake <= 0 then
brake_input
:
[object Object]
brakelights
:
[object Object]
checkengine
[3]
0
:
electrics.values.checkengine = false
1
:
electrics.values.checkengine = controlLogicModule.checkEngine or false
2
:
gaugeData.electrics.checkengine = electrics.values.checkengine
clutch
[3]
0
:
electrics.values.clutch = math.min(math.max(input.clutch or 0, 0), 1)
1
:
electrics.values.clutchRatio = 1 - electrics.values.clutch
2
:
o.clutch = electrics.values.clutch
clutchRatio
[2]
0
:
electrics.values.clutchRatio = 1 - electrics.values.clutch
1
:
--print(string.format("Clutch1: %.2f, Clutch 2: %.2f",electrics.values.clutchRatio1,electrics.values.clutchRatio2))
clutch_input
:
[object Object]
dseColor
[2]
0
:
electrics.values.dseColor = controlParameters.uiDisplayData.simplePowertrainApp.activeColor
1
:
electrics.values.dseColor = currentESCConfiguration.activeColor
engineLoad
[3]
0
:
electrics.values.engineLoad or 0,
1
:
if (electrics.values.engineLoad or 0) <= 0 then
2
:
electrics.values.engineLoad = controlLogicModule.engineLoad or 0
engineRunning
[3]
0
:
if electrics.values.engineRunning == 0 then
1
:
electrics.values.engineRunning = controlLogicModule.isEngineRunning or 0
2
:
gaugeData.electrics.engineRunning = electrics.values.engineRunning
engineThrottle
[2]
0
:
electrics.values.engineThrottle = 0
1
:
electrics.values.engineThrottle = controlLogicModule.engineThrottle or 0
esc
[3]
0
:
local isESCActive = electrics.values.escActive
1
:
electrics.values.esc = escPulse
2
:
electrics.values.escActive = escActive
escActive
[3]
0
:
local isESCActive = electrics.values.escActive
1
:
electrics.values.escActive = escActive
2
:
local escCoef = electrics.values.escActive and 0 or 1
fog
[1]
0
:
if electrics.values.fog == 1 then e.color = '#ff6600'
fuel
[3]
0
:
electrics.values.fuel or 0,
1
:
electrics.values.fuelCapacity or 0,
2
:
electrics.values.fuelVolume or 0,
fuelCapacity
[2]
0
:
electrics.values.fuelCapacity or 0,
1
:
electrics.values.fuelCapacity = energyStorageData.invEnergyStorageCount > 0 and (energyStorageData.capacity or 0) or 1
fuelVolume
[3]
0
:
electrics.values.fuelVolume or 0,
1
:
local fuelVolume = electrics.values.fuelVolume or 0
2
:
electrics.values.fuelVolume = energyStorageData.volume
gear
[3]
0
:
electrics.values.gear_A = 0
1
:
electrics.values.gear_M = 0
2
:
electrics.values.gearIndex or 0,
gearIndex
[3]
0
:
electrics.values.gearIndex or 0,
1
:
electrics.values.gearIndex = 0
2
:
if not currentESCConfiguration.escEnabled or (electrics.values.gearIndex or 0) < 0 then
gear_A
[2]
0
:
electrics.values.gear_A = 0
1
:
electrics.values.gear_A = gearPosition
hasABS
[2]
0
:
local hasABS = electrics.values.hasABS or false
1
:
electrics.values.hasABS = hasABS
hazard
[3]
0
:
if electrics.values.hazard_enabled == 1 then e.color = '#ff0000'
1
:
if electrics.values.hazard_enabled == 0 and (electrics.values.signal_left_input == 1 or electrics.values.signal_right_input == 1) then e.color = '#33ff33'
2
:
if electrics.values.hazard_enabled == 0 and electrics.values.signal_left_input == 1 then e.color = '#33ff33'
hazard_enabled
[3]
0
:
if electrics.values.hazard_enabled == 1 then e.color = '#ff0000'
1
:
if electrics.values.hazard_enabled == 0 and (electrics.values.signal_left_input == 1 or electrics.values.signal_right_input == 1) then e.color = '#33ff33'
2
:
if electrics.values.hazard_enabled == 0 and electrics.values.signal_left_input == 1 then e.color = '#33ff33'
highbeam
[3]
0
:
if electrics.values.highbeam ~= 0 then
1
:
gaugeData.electrics.highbeam = electrics.values.highbeam
2
:
gaugeData.electrics.highbeam = electrics.values.highbeam
horn
[1]
0
:
if electrics.values.horn ~= 0 then states.horn = electrics.values.horn
ignition
[3]
0
:
electrics.values.ignition = true
1
:
electrics.values.running = electrics.values.ignition
2
:
electrics.values.ignition = controlLogicModule.ignition == nil and true or controlLogicModule.ignition
isShifting
[3]
0
:
if electrics.values.isShifting then
1
:
electrics.values.isShifting = controlLogicModule.isShifting or false
2
:
local slip = electrics.values.isShifting and wheelData.lastSlip or wheelSlip
isTCBrakeActive
[1]
0
:
electrics.values.isTCBrakeActive = isTCBrakeActive
isYCBrakeActive
[3]
0
:
if electrics.values.isYCBrakeActive ~= nil then
1
:
isESCActive = electrics.values.isYCBrakeActive
2
:
electrics.values.isYCBrakeActive = isYCBrakeActive
lightbar
[3]
0
:
electrics.values[electricsName] = electrics.values.lightbar > 0 and ((electrics.values.beaconSpin + (dt * beaconSpeed)) % 360) or 0
1
:
if lastLightbarElectric ~= electrics.values.lightbar then
2
:
lastLightbarElectric = electrics.values.lightbar
lights
[3]
0
:
if electrics.values.lights_state == 1 then e.color = '#33ff33'; e.icon = 'radial_headlights_low'
1
:
if electrics.values.lights_state == 2 then e.color = '#3333ff'
2
:
if electrics.values.lights_state == 0 then e.color = '#ff6600'
lights_state
[3]
0
:
if electrics.values.lights_state == 1 then e.color = '#33ff33'; e.icon = 'radial_headlights_low'
1
:
if electrics.values.lights_state == 2 then e.color = '#3333ff'
2
:
if electrics.values.lights_state == 0 then e.color = '#ff6600'
lockupClutchRatio
[3]
0
:
electrics.values.lockupClutchRatio = torqueConverterHandling.lockupSmoother:getUncapped(lockupTarget, dt)
1
:
electrics.values.lockupClutchRatio = torqueConverterHandling.lockupSmoother:getUncapped(lockupTarget, dt)
2
:
electrics.values.lockupClutchRatio = min(max((engineAV - torqueConverterHandling.lockupAV) / torqueConverterHandling.lockupRange, 0), 1)
lowbeam
:
[object Object]
lowfuel
[3]
0
:
electrics.values.lowfuel = false
1
:
electrics.values.lowfuel = electrics.values.fuel < 0.1
2
:
gaugeData.electrics.lowfuel = electrics.values.lowfuel
lowhighbeam
:
[object Object]
lowpressure
[1]
0
:
gaugeData.electrics.lowpressure = electrics.values.lowpressure
odometer
:
[object Object]
oil
[3]
0
:
electrics.values.oil or 0,
1
:
electrics.values.oiltemp or 0,
2
:
electrics.values.oiltemp = 0
oiltemp
[3]
0
:
electrics.values.oiltemp or 0,
1
:
electrics.values.oiltemp = 0
2
:
o.oilTemp = electrics.values.oiltemp or 0
parking
[3]
0
:
local isUsingParkingBrake = electrics.values.parkingbrake > 0
1
:
if electrics.values.parkingbrake ~= 0 then
2
:
gaugeData.electrics.parkingbrake = electrics.values.parkingbrake
parkingbrake
[3]
0
:
local isUsingParkingBrake = electrics.values.parkingbrake > 0
1
:
if electrics.values.parkingbrake ~= 0 then
2
:
gaugeData.electrics.parkingbrake = electrics.values.parkingbrake
parkingbrake_input
:
[object Object]
radiatorFanSpin
[2]
0
:
electrics.values.radiatorFanSpin or 0,
1
:
electrics.values.radiatorFanSpin = (engine and engine.thermals) and engine.thermals.radiatorFanSpin or 0
reverse
:
[object Object]
rpm
[3]
0
:
electrics.values.rpm or 0,
1
:
electrics.values.rpmspin or 0,
2
:
electrics.values.rpm = 0
rpmTacho
[2]
0
:
gaugeData.electrics.rpmTacho = electrics.values.rpmTacho
1
:
gaugeData.electrics.rpmTacho = electrics.values.rpmTacho
rpmspin
[1]
0
:
electrics.values.rpmspin or 0,
running
[2]
0
:
electrics.values.running = electrics.values.ignition
1
:
electrics.values.running = controlLogicModule.ignition == nil and true or controlLogicModule.ignition
signal_L
[3]
0
:
if electrics.values.signal_L ~= 0 then
1
:
gaugeData.electrics.signal_L = electrics.values.signal_L
2
:
gaugeData.electrics.signal_L = electrics.values.signal_L
signal_R
[3]
0
:
if electrics.values.signal_R ~= 0 then
1
:
gaugeData.electrics.signal_R = electrics.values.signal_R
2
:
gaugeData.electrics.signal_R = electrics.values.signal_R
signal_left_input
[2]
0
:
if electrics.values.hazard_enabled == 0 and (electrics.values.signal_left_input == 1 or electrics.values.signal_right_input == 1) then e.color = '#33ff33'
1
:
if electrics.values.hazard_enabled == 0 and electrics.values.signal_left_input == 1 then e.color = '#33ff33'
signal_right_input
[2]
0
:
if electrics.values.hazard_enabled == 0 and (electrics.values.signal_left_input == 1 or electrics.values.signal_right_input == 1) then e.color = '#33ff33'
1
:
if electrics.values.hazard_enabled == 0 and electrics.values.signal_right_input == 1 then e.color = '#33ff33'
smoothShiftLogicAV
[2]
0
:
local brake = clamp(-speedDif, brakeLimLow, 1) * sign(max(0, electrics.values.smoothShiftLogicAV or 0 - 3)) -- arcade autobrake comes in at |smoothShiftLogicAV| < 5
1
:
electrics.values.smoothShiftLogicAV = smoothedValues.avgAV -- the smoothed AV shiftlogic uses to determine arcade reverse switch and auto braking (among other things), exposed for the AI to use
steering
[3]
0
:
steeringBiasCoef = linearScale(abs(electrics.values.steering), 0.1, 0.3, 0, 1) * fsign(electrics.values.steering) * gForceCoef * throttleCoef
1
:
local wheelpos = electrics.values.steering_input or 0
2
:
electrics.values.steering = -steeringHydro.hydroDirState * v.data.input.steeringWheelLock
steering_input
[2]
0
:
local wheelpos = electrics.values.steering_input or 0
1
:
local steeringSign = fsign(electrics.values.steering_input)
tcs
[3]
0
:
electrics.values.tcs = tcsPulse
1
:
electrics.values.tcsActive = tcsActive
2
:
if electrics.values.esc ~= 0 or electrics.values.tcs ~= 0 then
tcsActive
[3]
0
:
electrics.values.tcsActive = tcsActive
1
:
electrics.values.tcsActive = isActiveSmoothed >= 1
2
:
gaugeData.electrics.tcsActive = electrics.values.tcsActive
throttle
[3]
0
:
if electrics.values.throttle > 0 then
1
:
local throttleCoef = linearScale(electrics.values.throttle or 0, 0, 0.5, 0, 1)
2
:
if electrics.values.throttle > 0 then
throttle_input
:
[object Object]
turnsignal
[2]
0
:
if intersection.turn < 0 and electrics.values.turnsignal >= 0 then
1
:
elseif intersection.turn > 0 and electrics.values.turnsignal <= 0 then
watertemp
[3]
0
:
electrics.values.watertemp or 0,
1
:
electrics.values.watertemp = 0
2
:
if not electrics.values.watertemp then
wheelThermals
{4}
FL
{3}
brakeCoreTemperature
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
FR
{3}
brakeCoreTemperature
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
RL
{3}
brakeCoreTemperature
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
RR
{3}
brakeCoreTemperature
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
wheelspeed
[3]
0
:
local wheelspeed = electrics.values.wheelspeed
1
:
local currentSpeed = electrics.values.wheelspeed or 0
2
:
rampedTargetSpeed = electrics.values.wheelspeed or 0
horn(state)
[2]
0
:
electrics.horn(true)
1
:
electrics.horn(false)
init()
[1]
0
:
electrics.init()
light_flash_highbeams(enabled)
:
[object Object]
reset()
[1]
0
:
electrics.reset()
setLightsState(newval)
:
[object Object]
set_fog_lights(state)
:
[object Object]
set_lightbar_signal(state)
:
[object Object]
set_warn_signal(value)
[3]
0
:
electrics.set_warn_signal(true)
1
:
electrics.set_warn_signal(false)
2
:
electrics.set_warn_signal(false)
toggle_fog_lights()
:
[object Object]
toggle_left_signal()
[1]
0
:
electrics.toggle_left_signal()
toggle_lightbar_signal()
:
[object Object]
toggle_lights()
:
[object Object]
toggle_right_signal()
[1]
0
:
electrics.toggle_right_signal()
toggle_warn_signal()
:
[object Object]
update(dt)
[1]
0
:
electrics.update(dtSim)
energyStorage
{10}
beamBroke(id)
[1]
0
:
energyStorage.beamBroke(id)
getPartCondition(partTypeData)
[1]
0
:
local energyStorageCondition, canProvideEnergyStorageCondition = energyStorage.getPartCondition(partData)
getStorage(name)
[3]
0
:
local storage = energyStorage.getStorage(s)
1
:
local storage = energyStorage.getStorage(s)
2
:
local storage = energyStorage.getStorage(storageName)
getStorages()
[3]
0
:
local energyStorages = energyStorage.getStorages()
1
:
local storages = energyStorage.getStorages()
2
:
local energyStorages = energyStorage.getStorages()
init()
[1]
0
:
energyStorage.init()
onDeserialize(data)
:
[object Object]
onSerialize()
:
[object Object]
reset()
[1]
0
:
energyStorage.reset()
setPartCondition(partTypeData, odometer, integrity, visual)
[1]
0
:
energyStorage.setPartCondition(partTypes, odometer, integrity, visual)
updateGFX(dt)
[1]
0
:
energyStorage.updateGFX(dtSim)
extensions
{33}
core_performance
{5}
onExtensionLoaded()
:
[object Object]
popEvent()
[3]
0
:
core_performance.popEvent() -- 3.1 init - compat
1
:
core_performance.popEvent() -- 3.2.X init - materials (sum)
2
:
core_performance.popEvent() -- 3.2 init - first stage
printReport()
[1]
0
:
--core_performance.printReport()
pushEvent(label)
[3]
0
:
core_performance.pushEvent("lua init")
1
:
core_performance.pushEvent("3.1 init - compat")
2
:
core_performance.pushEvent("3.2.X init - materials (sum)")
saveReportToCSV(filename)
:
[object Object]
core_quickAccess
{5}
addEntry(_args)
[3]
0
:
core_quickAccess.addEntry(
1
:
core_quickAccess.addEntry(
2
:
core_quickAccess.addEntry(
onExtensionLoaded()
:
[object Object]
registerMenu()
:
[object Object]
requestItems(level)
:
[object Object]
selectItem(id)
:
[object Object]
addModulePath(directory)
[2]
0
:
extensions.addModulePath("lua/vehicle/extensions/")
1
:
extensions.addModulePath("lua/common/extensions/")
deserialize(data, filter)
[1]
0
:
extensions.deserialize(data)
extNameToLuaPath(extName)
:
[object Object]
getLoadedExtensionsNames()
:
[object Object]
getSerializationData(reason)
[1]
0
:
tableMerge(tmp, extensions.getSerializationData(reason))
hook(func)
[3]
0
:
obj:queueGameEngineLua(string.format('extensions.hook("startTracking", {Name = "ControlsUsed", Method = "%s"})', filterTypes[e.filter]))
1
:
extensions.hook("updateGFX", dtSim) -- must be before drivetrain, hydros and after electrics
2
:
extensions.hook("onDebugDraw", focusPos)
hookCount(func)
:
[object Object]
hookExcept(exceptionList, func)
:
[object Object]
hookNotify(func)
:
[object Object]
isExtensionLoaded(extName)
:
[object Object]
load()
[3]
0
:
obj:queueGameEngineLua("extensions.load('core_vehicleMirrors')")
1
:
extensions.load('core_vehicleMirrors')
2
:
extensions.load("perfectLaunch")
loadAtRoot(extPath, rootName)
:
[object Object]
loadModule(extName)
:
[object Object]
loadModulesInDirectory(directory, excludeSubdirectories)
[2]
0
:
extensions.loadModulesInDirectory(path .. "/lua", {"controller", "powertrain", "energyStorage"})
1
:
extensions.loadModulesInDirectory("lua/vehicle/extensions/auto")
luaPathToExtName(filepath)
:
[object Object]
onDeserialize()
:
[object Object]
onDeserialized()
:
[object Object]
onSerialize()
:
[object Object]
printExtensions()
:
[object Object]
printHooks(funcName)
:
[object Object]
refresh(extName)
:
[object Object]
reload(extPath)
[1]
0
:
extensions.reload("straightLine")
reloadModule(modulePath)
:
[object Object]
restoreModulePath()
:
[object Object]
saveModulePath()
:
[object Object]
setCompletedCallback(funcName, callback)
:
[object Object]
setProfiler(p)
:
[object Object]
unload(extName)
:
[object Object]
unloadExcept()
:
[object Object]
unloadModule(extName)
:
[object Object]
use(key)
:
[object Object]
ffi
{20}
C
:
[object Object]
arch
:
[object Object]
os
:
[object Object]
abi(*)
:
[object Object]
alignof(*)
:
[object Object]
cast(*)
[1]
0
:
-- local f = ffi.cast("ImFont*", imgui.GetIO().Fonts.Fonts.Data) -- Data is an ImVector, so do some pointer math
cdef(*)
[2]
0
:
ffi.cdef([[
1
:
ffi.cdef(readFile('lua/common/extensions/ui/imgui_gen.h'))
copy(*)
:
[object Object]
errno(*)
:
[object Object]
fill(*)
:
[object Object]
gc(*)
:
[object Object]
istype(*)
[1]
0
:
elseif (ffi and ffi.istype('struct __luaVec3_t', b)) or b.w == nil then
load(*)
:
[object Object]
metatype(*)
[3]
0
:
ffi.metatype("struct __LuaColor_t", LuaColor)
1
:
local ImTextureHandler_constructor = ffi.metatype("ImTextureHandler", ImTextureHandler_mt)
2
:
boolset_constructor = ffi.metatype('struct { int upper; bool v[?]; }', byteset_mt)
new(*)
[3]
0
:
local style = ffi.new('ImGuiStyle[1]')
1
:
local dataPlot = ffi.new("float[" .. dataPlotLen .. "]", 0)
2
:
local res = ffi.new("ImVec2")
offsetof(*)
[3]
0
:
if ffi.offsetof(v, 'z') ~= nil then -- vec3
1
:
if ffi.offsetof(v, 'w') ~= nil then -- quat
2
:
elseif vtype == 'cdata' and ffi.offsetof(v, 'z') ~= nil then -- vec3
sizeof(*)
[3]
0
:
-- f = f + ffi.sizeof('ImFont') -- second font
1
:
if not buf_size then buf_size = ffi.sizeof(buf)
2
:
if not buf_size then buf_size = ffi.sizeof(buf)
string(*)
[3]
0
:
local packet = ffi.string(o, ffi.sizeof(o))
1
:
local packet = ffi.string(o, ffi.sizeof(o)) --convert the struct into a string
2
:
local packet = ffi.string(o, ffi.sizeof(o))
typeinfo(*)
:
[object Object]
typeof(*)
[3]
0
:
newLuaColorrgba = ffi.typeof("struct __LuaColor_t")
1
:
newLuaVec3xyz = ffi.typeof("struct __luaVec3_t")
2
:
newLuaQuatxyzw = ffi.typeof("struct __luaQuat_t")
ffiObjPtr
[2]
0
:
ffi.C.bng_applyTorqueAxisCouple(ffiObjPtr, inertialTorque, device.torqueReactionNodes[1], device.torqueReactionNodes[2], device.torqueReactionNodes[3])
1
:
ffiWheelCoreData = ffi.C.bng_getWheelCoreData(ffiObjPtr)
fire
{14}
debugData
{1}
flammableNodes
:
[object Object]
explodeNode(cid)
:
[object Object]
explodeVehicle()
:
[object Object]
extinguishVehicle()
:
[object Object]
extinguishVehicleSlowly()
:
[object Object]
getClosestHotNodeTempDistance(cid)
[3]
0
:
local fireTemperature, fireDistance = fire.getClosestHotNodeTempDistance(parentEngine.engineNodeID)
1
:
local fireTemperature, fireDistance = fire.getClosestHotNodeTempDistance(parentEngine.engineNodeID)
2
:
local fireTemperature, fireDistance = fire.getClosestHotNodeTempDistance(wd.node1)
igniteNode(cid)
:
[object Object]
igniteRandomNode()
:
[object Object]
igniteRandomNodeMinimal()
:
[object Object]
igniteVehicle()
:
[object Object]
init()
[1]
0
:
fire.init()
nodeCollision(p)
[1]
0
:
fire.nodeCollision(p)
reset()
[1]
0
:
fire.reset()
updateGFX(dt)
[1]
0
:
fire.updateGFX(dtSim)
gui
{9}
updateStreams
:
[object Object]
frameUpdated()
:
[object Object]
message(msg, ttl, category, icon)
:
[object Object]
queueStreamLuaFrame(key, value)
:
[object Object]
reset()
:
[object Object]
send(key, value)
[3]
0
:
gui.send('advancedWheelDebugData', data)
1
:
gui.send("escInfo", appData)
2
:
gui.send("engineThermalData", engineThermalData)
trigger(hookName)
:
[object Object]
triggerRawJS(hookName, rawJs)
:
[object Object]
triggerStream(streamName, streamData)
:
[object Object]
guihooks
{9}
updateStreams
[3]
0
:
return guihooks.updateStreams and streamControl[name]
1
:
guihooks.updateStreams = true
2
:
guihooks.updateStreams = false
frameUpdated()
[1]
0
:
guihooks.frameUpdated()
message(msg, ttl, category, icon)
[3]
0
:
guihooks.message("Range status: "..rangeBox.mode, 10, "vehicle.powertrain.rangestatus")
1
:
guihooks.message("Range status: "..rangeBox.mode, 10, "vehicle.powertrain.rangestatus")
2
:
guihooks.message("4WD Status: "..shaft.mode, 10, "vehicle.powertrain.shaftstatus")
queueStreamLuaFrame(key, value)
[3]
0
:
guihooks.queueStreamLuaFrame("wheelInfo", wheelInfo)
1
:
guihooks.queueStreamLuaFrame("engineInfo", controller.mainController.engineInfo)
2
:
guihooks.queueStreamLuaFrame("electrics", electrics.values)
reset()
[1]
0
:
guihooks.reset()
send(key, value)
:
[object Object]
trigger(hookName)
[3]
0
:
guihooks.trigger("AIStatusChange", {status=status, category=category})
1
:
guihooks.trigger("AIStateChange", getState())
2
:
guihooks.trigger("VehicleSkeletonState", beamDamageTracker)
triggerRawJS(hookName, rawJs)
:
[object Object]
triggerStream(streamName, streamData)
:
[object Object]
hydros
{21}
GforceCoef
:
[object Object]
curForceLimit
[1]
0
:
lsensors.maxffb = tonumber(hydros.curForceLimit)
enableFFB
:
[object Object]
forceAtDriver
[1]
0
:
lsensors.ffbAtDriver = tonumber(hydros.forceAtDriver)
forceAtWheel
[1]
0
:
lsensors.ffbAtWheel = tonumber(hydros.forceAtWheel)
hydros
:
[object Object]
wheelFFBForceCoef
:
[object Object]
wheelFFBForceCoefCurrent
:
[object Object]
wheelFFBForceCoefLowSpeed
:
[object Object]
wheelFFBForceLimit
:
[object Object]
wheelFFBSmoothing
:
[object Object]
wheelPowerSteeringCoef
[3]
0
:
hydros.wheelPowerSteeringCoef = strengthCoef
1
:
hydros.wheelPowerSteeringCoef = 1 + constantOffset
2
:
hydros.wheelPowerSteeringCoef = 1 + constantOffset
destroy()
[1]
0
:
hydros.destroy()
init()
[1]
0
:
hydros.init()
isPhysicsStepUsed()
:
[object Object]
onFFBConfigChanged(newFFBConfig)
:
[object Object]
reset()
[1]
0
:
hydros.reset()
sendHydroStateToGUI()
:
[object Object]
sendRPMLeds(currentRPM, rpmFirstLedTurnsOn, rpmRedLine)
[1]
0
:
-- hydros.sendRPMLeds(engine.outputAV1 or 0, (engine.maxAV or 1) * 0.8, engine.maxAV or 1)
update(dtSim)
[1]
0
:
hydros.update(dtSim)
updateGFX(dt)
[1]
0
:
hydros.updateGFX(dtSim) -- must be after (input, electrics) and before props
input
{17}
brake
[3]
0
:
inputs.brake = input.brake
1
:
inputs.throttlebrake = input.throttle - input.brake
2
:
if input.brake > 0 then
clutch
[3]
0
:
if input.clutch > 0 or input.throttle > 0 then
1
:
electrics.values.clutch = math.min(math.max(input.clutch or 0, 0), 1)
2
:
inputValues.clutch = electrics.values.clutchOverride or min(max(input.clutch or 0, 0), 1)
filterSettings
:
[object Object]
lastFilterType
:
[object Object]
parkingbrake
[3]
0
:
local parkingbrake = input.parkingbrake
1
:
input.parkingbrake,
2
:
if (brake > airspeedBrakeThreshold or input.parkingbrake ~= 0) and airspeedMapTimer == 0 then
state
{5}
brake
{8}
angle
:
[object Object]
filter
:
[object Object]
lockType
:
[object Object]
maxLimit
:
[object Object]
minLimit
:
[object Object]
smootherKBD
{3}
autoCenterRate
:
[object Object]
state
:
[object Object]
getUncapped(self, sample, dt)
:
[object Object]
smootherPAD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
val
[3]
0
:
elseif input.state.parkingbrake.val > 0.5 then
1
:
input.state.parkingbrake.val = 1
2
:
input.state.parkingbrake.val = 1
clutch
{6}
filter
:
[object Object]
maxLimit
:
[object Object]
minLimit
:
[object Object]
smootherKBD
{3}
autoCenterRate
:
[object Object]
state
:
[object Object]
getUncapped(self, sample, dt)
:
[object Object]
smootherPAD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
val
:
[object Object]
parkingbrake
{8}
angle
:
[object Object]
filter
:
[object Object]
lockType
:
[object Object]
maxLimit
:
[object Object]
minLimit
:
[object Object]
smootherKBD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
smootherPAD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
val
[3]
0
:
elseif input.state.parkingbrake.val > 0.5 then
1
:
input.state.parkingbrake.val = 1
2
:
input.state.parkingbrake.val = 1
steering
{6}
filter
:
[object Object]
maxLimit
:
[object Object]
minLimit
:
[object Object]
smootherKBD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
smootherPAD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
val
:
[object Object]
throttle
{8}
angle
:
[object Object]
filter
[1]
0
:
local usesKeyboard = input.state.throttle.filter == FILTER_KBD or input.state.throttle.filter == FILTER_KBD2
lockType
:
[object Object]
maxLimit
:
[object Object]
minLimit
:
[object Object]
smootherKBD
{3}
autoCenterRate
:
[object Object]
state
:
[object Object]
getUncapped(self, sample, dt)
:
[object Object]
smootherPAD
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
val
[3]
0
:
--smooth our actual throttle value to simulate various effects in a real engine that do not allow immediate throttle changes
1
:
--dont't do anything if we use the clutch or if we manually input a throttle value
2
:
--Used for decision logic, smoothed throttle is not actually used as the throttle value
steering
[3]
0
:
inputs.steering = input.steering
1
:
local steeringInput = input.steering
2
:
electrics.values.steering = -steeringHydro.hydroDirState * v.data.input.steeringWheelLock
throttle
[3]
0
:
inputs.throttle = input.throttle
1
:
inputs.throttlebrake = input.throttle - input.brake
2
:
if input.clutch > 0 or input.throttle > 0 then
event(itype, ivalue, filter, angle, lockType)
[3]
0
:
input.event("steering", steering, 1)
1
:
input.event("throttle", throttle, 2)
2
:
input.event("brake", brake, 2)
init()
[1]
0
:
input.init()
initSecondStage()
[1]
0
:
input.initSecondStage() -- needs to go after sounds & electrics
kbdSteer(isRight, val, filter)
:
[object Object]
padAccelerateBrake(val, filter)
:
[object Object]
reset()
[1]
0
:
input.reset()
settingsChanged()
[1]
0
:
input.settingsChanged()
toggleEvent(itype)
[1]
0
:
input.toggleEvent("parkingbrake")
updateGFX(dt)
[1]
0
:
input.updateGFX(dtSim) -- must be as early as possible
io
{14}
stderr
{7}
close(*)
:
[object Object]
flush(*)
:
[object Object]
lines(*)
:
[object Object]
read(*)
:
[object Object]
seek(*)
:
[object Object]
setvbuf(*)
:
[object Object]
write(*)
[1]
0
:
io.stderr:write(debug.traceback("TimerWheel callback failed with: " .. tostring(err)))
stdin
{7}
close(*)
:
[object Object]
flush(*)
:
[object Object]
lines(*)
:
[object Object]
read(*)
:
[object Object]
seek(*)
:
[object Object]
setvbuf(*)
:
[object Object]
write(*)
:
[object Object]
stdout
{7}
close(*)
:
[object Object]
flush(*)
:
[object Object]
lines(*)
:
[object Object]
read(*)
:
[object Object]
seek(*)
:
[object Object]
setvbuf(*)
:
[object Object]
write(*)
:
[object Object]
close(*)
[2]
0
:
io.close(file)
1
:
io.close(f)
flush(*)
:
[object Object]
input(*)
:
[object Object]
lines(*)
:
[object Object]
open(*)
[3]
0
:
csvHandle, err = io.open(path, 'w')
1
:
local f = assert( io.open( fname, "r" ) )
2
:
local filePivot = io.open("skewStiffnessPivot.csv", "w")
output(*)
:
[object Object]
popen(*)
:
[object Object]
read(*)
[1]
0
:
local cmd = io.read()
tmpfile(*)
:
[object Object]
type(*)
:
[object Object]
write(*)
[3]
0
:
--io.write("sandboxed print: " .. tostring(msg) .. "\n")
1
:
io.write("> ")
2
:
io.write("<")
jit
{11}
arch
:
[object Object]
opt
{1}
start(*)
:
[object Object]
os
:
[object Object]
version
[3]
0
:
assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
1
:
assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
2
:
assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
version_num
[3]
0
:
assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
1
:
assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
2
:
assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
attach(*)
[2]
0
:
jit.attach(dump_trace)
1
:
jit.attach(dump_trace, "trace")
flush(*)
:
[object Object]
off(*)
:
[object Object]
on(*)
:
[object Object]
security(*)
:
[object Object]
status(*)
[1]
0
:
jit = jit and jit.status(),
json
{1}
decode(si)
[2]
0
:
local t = json.decode(jsontext)
1
:
return json.decode(body)
lastDt
[3]
0
:
local collisionEnergy = p.slipForce * p.slipVel * lastDt
1
:
local t = min(1, dtInternal / max(1e-30, lastDt))
2
:
lastDt = 1 / 20
lpack
{4}
decode(is)
[1]
0
:
_map = lpack.decode(_map)
decodeLua(s)
:
[object Object]
encode(v)
:
[object Object]
encodeLua(v)
:
[object Object]
luaVMInstanceName
[1]
0
:
dbg.start(luaVMInstanceName or 'default', {logFunc = log, debugCommunication = true}) -- luaVMInstanceName should be hardcoded in c++
mapmgr
{13}
objects
:
[object Object]
disableTracking(forceDisable)
:
[object Object]
enableTracking(name)
[1]
0
:
mapmgr.enableTracking()
findClosestRoad(position)
[3]
0
:
n1, n2, dist = mapmgr.findClosestRoad(aiPos)
1
:
local wp1, wp2 = mapmgr.findClosestRoad(aiPos)
2
:
local wp1, wp2, dist1 = mapmgr.findClosestRoad(aiPos)
getPointToPointPath(startPos, targetPos, cutOffDrivability, dirMult, penaltyAboveCutoff, penaltyBelowCutoff, wZ)
:
[object Object]
init()
[1]
0
:
mapmgr.init()
objectData(objectsData)
:
[object Object]
requestMap()
:
[object Object]
reset()
[1]
0
:
mapmgr.reset()
sendTracking()
[1]
0
:
mapmgr.sendTracking() -- must be before ai
setMap(newbuildSerial, _map)
:
[object Object]
surfaceNormalBelow(p, r)
[2]
0
:
up = mapmgr.surfaceNormalBelow(pos)
1
:
up = mapmgr.surfaceNormalBelow(pos)
updateSignal(node, idx, action)
:
[object Object]
material
{6}
mv
{19}
abswarn
:
[object Object]
brakelights
:
[object Object]
checkengine
:
[object Object]
esc
:
[object Object]
fog
:
[object Object]
highbeam
:
[object Object]
lowbeam
:
[object Object]
lowfuel
:
[object Object]
lowhighbeam
:
[object Object]
lowpressure
:
[object Object]
oil
:
[object Object]
parking
:
[object Object]
parkingbrake
:
[object Object]
rearfog
:
[object Object]
reverse
:
[object Object]
running
:
[object Object]
signal_L
:
[object Object]
signal_R
:
[object Object]
tcs
:
[object Object]
forceReset()
[1]
0
:
material.forceReset() --here on purpurse, it get called a second type on key up and then it fixed what ever material was stuck
init()
[1]
0
:
material.init()
reset()
[1]
0
:
material.reset()
switchBrokenMaterial(beam)
[1]
0
:
material.switchBrokenMaterial(beam)
updateGFX()
[1]
0
:
material.updateGFX()
math
{30}
huge
[3]
0
:
local targetSpeedSmoother = nil -- = newTemporalSmoothingNonLinear(math.huge, 0.2)
1
:
local bestDist = math.huge
2
:
intersection.planStop = math.huge
pi
[3]
0
:
local pi = math.pi
1
:
engine.dynamicFriction = (oldEngine.brakingCoefRPS or 0.2) / (2 * math.pi)
2
:
device.lockTorque = device.lockTorque or (device.parent.torqueData.maxTorque + device.parent.maxRPM * device.parent.inertia * math.pi / 60)
abs(*)
[3]
0
:
local absStress = math.abs(stress)
1
:
if math.abs(deform) > minDeform then
2
:
local a = math.min((math.abs(deform) - minDeform) / deformRange, 1) * 255
acos(*)
[2]
0
:
local theta = math.acos(dot)*t
1
:
local tw = math.acos(self.w) * 360 / math.pi
asin(*)
[3]
0
:
local dirAngle = math.asin(ai.rightVec:dot(targetVec))
1
:
local dirDiff = math.asin(aiDirVec:cross(ai.upVec):normalized():dot(targetVec))
2
:
math.asin(max(min(-2*(q.y*q.z - q.w*q.x), 1), -1)),
atan(*)
:
[object Object]
atan2(*)
[2]
0
:
math.atan2(2*(q.x*q.y + q.w*q.z), wxsq-yzsq),
1
:
math.atan2(2*(q.x*q.z + q.w*q.y), wxsq+yzsq))
ceil(*)
[3]
0
:
saveInfo({["Off-Road Score"] = math.ceil(((3 * distance + beamBrokenDistance) / 500 / 4) * 100)}, {"Off-Road Score"})
1
:
local n = math.max(5, math.ceil(math.log10(ms)))
2
:
local n = math.max(5, math.ceil(math.log10(ms)))
cos(*)
[3]
0
:
return (self*math.cos(theta) + (a - self*dot):normalized()*math.sin(theta)):normalized();
1
:
-- return newLuaQuatxyzw( coef*self.x, coef*self.y, coef*self.z, -ret* math.cos(vlen) )
2
:
return newLuaQuatxyzw(fsin * axle.x, fsin * axle.y, fsin * axle.z, math.cos(angleRad))
cosh(*)
:
[object Object]
deg()
[3]
0
:
local rotation = math.deg(obj:getDirection()) + 180
1
:
--print(string.format("Wanted: %.2f, used %.2f instead, current angle: %.2f", math.deg(angle), math.deg(device.targetAngle), math.deg(device.currentAngle)))
2
:
maxSteerAngle = maxSteerAngle + math.deg(esc.wheelAngleFront)
exp(*)
[3]
0
:
-- local ret = math.exp(self.w)
1
:
local sigma1 = 1 / (1 + math.exp(-z1))
2
:
local sigma2 = 1 / (1 + math.exp(-z2))
floor(*)
[3]
0
:
local particleType = 55 + math.floor(math.random(3)) --choose random particle number between 56 and 58 for plastic chunks
1
:
local currentEngineEfficiency = burnEfficiencyCoef[math.floor(parentEngine.engineLoad * 100)]
2
:
local currentEngineEfficiency = burnEfficiencyCoef[math.floor(parentEngine.engineLoad * 100)]
fmod(*)
[3]
0
:
if math.fmod(#data,8) ~= 0 then
1
:
missing_digits = 8 - math.fmod(#data,8)
2
:
assert(math.fmod(#data,8) == 0)
frexp(*)
:
[object Object]
ldexp(*)
:
[object Object]
log(*)
:
[object Object]
log10(*)
[3]
0
:
local n = math.max(5, math.ceil(math.log10(ms)))
1
:
serTmp[seridx] = vlen < 10 and 'A' or (vlen < 100 and 'B' or string.char(65 + math.floor(math.log10(vlen))))
2
:
local n = math.max(5, math.ceil(math.log10(ms)))
max(*)
[3]
0
:
local r = math.max(-1, math.min(0, (stress + stressMin) * scaler)) * 255 * -1 -- (red compression)
1
:
local b = math.max(0, math.min(1, (stress - stressMin) * scaler)) * 255 -- (blue extension)
2
:
local r = math.max(-1, math.min(0, stress)) * 255 * -1
min(*)
[3]
0
:
mainController.clutchLaunchTargetRPM = math.min(v.data.engine.idleRPM * 3, v.data.engine.maxRPM / 2)
1
:
mainController.clutchLaunchStartRPM = math.min(v.data.engine.idleRPM * 2, v.data.engine.maxRPM / 2)
2
:
local r = math.max(-1, math.min(0, (stress + stressMin) * scaler)) * 255 * -1 -- (red compression)
modf(*)
:
[object Object]
pow(*)
:
[object Object]
rad()
[3]
0
:
ab.rotation = vec3(math.rad(rotDeg.x), math.rad(rotDeg.y), math.rad(rotDeg.z))
1
:
ab.baseRotation = vec3(math.rad(rot.x), math.rad(rot.y), math.rad(rot.z))
2
:
prop.rotation = vec3(math.rad(rotDeg.x), math.rad(rotDeg.y), math.rad(rotDeg.z))
random(*)
[3]
0
:
local edge = keySet[math.random(keySetLen)]
1
:
trafficBlock.limit = math.random() * 10 + 5
2
:
trafficBlock.horn = math.random() >= 0.4 and trafficBlock.limit - (math.random() * 2.5) or math.huge -- horn time start
randomseed(*)
[3]
0
:
math.randomseed(os.time())
1
:
math.randomseed(os.time())
2
:
math.randomseed(os.time())
sin(*)
[3]
0
:
return (self*math.cos(theta) + (a - self*dot):normalized()*math.sin(theta)):normalized();
1
:
-- local coef = ret * math.sin(vlen) / (vlen + 1e-60)
2
:
local fsin = math.sin(angleRad)
sinh(*)
:
[object Object]
sqrt(*)
[3]
0
:
searchRadius = math.sqrt(max(minCurDist, searchRadiusSq * 4))
1
:
return bestRoad1, bestRoad2, math.sqrt(bestDist)
2
:
local sinhalf = math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)
tan(*)
:
[object Object]
tanh(*)
:
[object Object]
mime
{8}
b64(*)
[3]
0
:
"Basic " .. (mime.b64(reqt.user .. ":" .. reqt.password))
1
:
"Basic " .. (mime.b64(reqt.user .. ":" .. reqt.password))
2
:
self.try(self.tp:send(mime.b64(user) .. "\r\n"))
dot(*)
:
[object Object]
eol(*)
:
[object Object]
qp(*)
:
[object Object]
qpwrp(*)
:
[object Object]
unb64(*)
:
[object Object]
unqp(*)
:
[object Object]
wrp(*)
:
[object Object]
motionSim
{6}
init()
:
[object Object]
isPhysicsStepUsed()
:
[object Object]
reset()
:
[object Object]
settingsChanged()
:
[object Object]
update()
:
[object Object]
updateGFX()
:
[object Object]
obj
{240}
addDecal(*)
:
[object Object]
addParticle(*)
:
[object Object]
addParticleByNodes(*)
[1]
0
:
obj:addParticleByNodes(cid, centreNode, -1, 48, 0, 15)
addParticleByNodesRelative(*)
[3]
0
:
obj:addParticleByNodesRelative(breakNode1, breakNode2, math.random(1), particleType, 0, 1)
1
:
obj:addParticleByNodesRelative(breakNode1, breakNode2, math.random(1), particleType_deformGroup1, (math.random(1) / 5), particleCount_deformGroup1) --spawn glass or wood particles
2
:
obj:addParticleByNodesRelative(breakNode1, breakNode2, math.random(1), particleType_deformGroup2, (math.random(1) / 5), particleCount_deformGroup2)
addParticleVelWidthTypeCount(*)
[1]
0
:
obj:addParticleVelWidthTypeCount(p, r.veloMult, r.width, r.particleType, r.count)
addRail(*)
[1]
0
:
rail.cid = obj:addRail(looped)
addRailLink(*)
[1]
0
:
obj:addRailLink(rail.cid, nid, lcapped, brokenmap[nid] or 0)
addSlidenode(*)
[1]
0
:
snode.cid = obj:addSlidenode(
addWheelNode(*)
[1]
0
:
obj:addWheelNode(wid, v)
apply2nodeTorque(*)
[1]
0
:
obj:apply2nodeTorque(axis:toFloat3(), torque, node1, node2)
apply3nodeTorque(*)
[1]
0
:
obj:apply3nodeTorque(axis:toFloat3(), torque, node1, node2, node3)
applyForce(*)
[3]
0
:
obj:applyForce(node1, node2, force)
1
:
obj:applyForce(thruster.id2, thruster.id1, t)
2
:
obj:applyForce(thruster[2], thruster[1], thruster[3])
applyForceTime(*)
:
[object Object]
applyForceVector(*)
[3]
0
:
obj:applyForceVector(node, forceVec:toFloat3())
1
:
obj:applyForceVector(stabilizationNodes.topCenter, (vectorUp * jumpForce):toFloat3())
2
:
obj:applyForceVector(cid, ballNodeForceVector)
applyForceVectorTime(*)
:
[object Object]
applyTorqueAxisCouple(*)
:
[object Object]
attachCoupler(*)
[2]
0
:
obj:attachCoupler(val.cid, val.couplerTag or "", val.couplerStrength or 1000000, val.couplerRadius or 0.2, val.couplerTargets or 0)
1
:
obj:attachCoupler(c.cid, c.couplerTag or "", c.couplerStrength or 1000000, c.couplerStartRadius, c.couplerTargets or 0)
attachSlidenode(*)
:
[object Object]
beamIsBroken(*)
[1]
0
:
local containerBeamBroken = obj:beamIsBroken(currentNode.containerBeam)
breakBeam(*)
[3]
0
:
obj:breakBeam(bcid)
1
:
obj:breakBeam(b.cid)
2
:
obj:breakBeam(b.cid)
breakCollisionTriangle(*)
[2]
0
:
obj:breakCollisionTriangle(ctid)
1
:
obj:breakCollisionTriangle(ctid)
breakMeshes(*)
[1]
0
:
obj:breakMeshes(id)
breakRails(*)
[1]
0
:
obj:breakRails(id)
calcBeamStats(*)
[3]
0
:
local stats = obj:calcBeamStats()
1
:
local stats = obj:calcBeamStats()
2
:
stats = obj:calcBeamStats()
calcCenterOfGravity(*)
[1]
0
:
-- local cgPos = obj:calcCenterOfGravity()
calcCenterOfGravityRel(*)
[1]
0
:
--local cog = vec3(obj:calcCenterOfGravityRel(true)) + obj:getPosition()
calcCenterOfPressureRel(*)
[2]
0
:
local cop = obj:calcCenterOfPressureRel()
1
:
local copVec = vec3(obj:calcCenterOfPressureRel() + obj:getPosition())
calcTotalAeroForces(*)
[1]
0
:
aeroData.totalAeroForce = vec3(obj:calcTotalAeroForces())
calcTotalAeroTorque(*)
[1]
0
:
aeroData.totalAeroTorque = vec3(obj:calcTotalAeroTorque(cop))
castRayStatic(*)
:
[object Object]
castRayStatic2(*)
:
[object Object]
changeGroupPressure(*)
:
[object Object]
changePressureGroupDrag(*)
[1]
0
:
obj:changePressureGroupDrag(v.data.pressureGroups[wheel.pressureGroup], 0)
closestNodeLineDistances(*)
:
[object Object]
commitLoad(*)
[1]
0
:
obj:commitLoad()
createSFXSource(*)
[3]
0
:
fireBurnSoundObj = obj:createSFXSource("event:>Vehicle>Fire>Fire_Burn_Loop", "AudioDefaultLoop3D", "fireburn", -1) or false
1
:
releaseSoundLoop = obj:createSFXSource(jbeamData.releaseSample or "event:>Vehicle>Hydraulics>Release_01", "AudioDefaultLoop3D", "", jbeamData.pumpNode)
2
:
groupData.soundLoopDown = obj:createSFXSource(v.soundDown, "AudioDefaultLoop3D", "pneumatics_down_" .. v.groupName, groupData.soundNode)
createSFXSource2(*)
[3]
0
:
starterSoundEngine = obj:createSFXSource2(jbeamData.starterSample or "event:>Engine>Starter>Old_V2", "AudioDefaultLoop3D", "", device.engineNodeID, 0),
1
:
device.engineMiscSounds.starterSoundExhaust = obj:createSFXSource2(jbeamData.starterSampleExhaust, "AudioDefaultLoop3D", "", starterExhaustNode, 0)
2
:
device.engineMiscSounds.shutOffSoundEngine = obj:createSFXSource2(jbeamData.shutOffSampleEngine, "AudioDefaultLoop3D", "", shutOffEngineNode, 0)
createWebView(*)
[1]
0
:
obj:createWebView(webViewTag, uri, width, height, usageModeID, fps)
cutSFX(*)
[3]
0
:
obj:cutSFX(device.engineMiscSounds.shutOffSoundEngine)
1
:
obj:cutSFX(device.engineMiscSounds.shutOffSoundExhaust)
2
:
obj:cutSFX(device.engineMiscSounds.starterSoundEngine)
deflatePressureGroup(*)
[1]
0
:
obj:deflatePressureGroup(v.data.pressureGroups[wheel.pressureGroup])
deleteSFXSource(*)
:
[object Object]
deleteSFXSources(*)
[1]
0
:
obj:deleteSFXSources()
destroyMaterials(*)
:
[object Object]
detachCoupler(*)
[2]
0
:
obj:detachCoupler(ccid)
1
:
obj:detachCoupler(val.cid)
detachSlidenode(*)
:
[object Object]
externalCouplerCount(*)
:
[object Object]
finishLoading(*)
[1]
0
:
obj:finishLoading()
get3nodeAngularVelocity(*)
[1]
0
:
local ballAV = obj:get3nodeAngularVelocity(ballTorqueAxis:toFloat3(), ballTorqueNodes[0], ballTorqueNodes[1], ballTorqueNodes[2])
getAerodynamicsMode(*)
:
[object Object]
getAerodynamicsState(*)
:
[object Object]
getAirDensity(*)
:
[object Object]
getAirDensityAtSeaLevel(*)
:
[object Object]
getAirSpeed(*)
:
[object Object]
getAirflowSpeed(*)
[2]
0
:
vals.airflowspeed = obj:getAirflowSpeed()
1
:
local speed = obj:getAirflowSpeed() -- speed against wind
getAltitude(*)
[1]
0
:
vals.altitude = obj:getAltitude()
getBeamCount(*)
:
[object Object]
getBeamCurLengthRefRatio(*)
:
[object Object]
getBeamDebugDeformation(*)
:
[object Object]
getBeamDeformation(*)
:
[object Object]
getBeamForce(*)
:
[object Object]
getBeamLength(*)
[1]
0
:
obj:setBeamLength(cid, obj:getBeamLength(cid))
getBeamLengthRefRatio(*)
:
[object Object]
getBeamLengthRestRatio(*)
:
[object Object]
getBeamRefLength(*)
[1]
0
:
h.invFFBHydroRefL = 1 / obj:getBeamRefLength(h.bcid)
getBeamRestLength(*)
:
[object Object]
getBeamStress(*)
[1]
0
:
local currentStress = clamp(obj:getBeamStress(snd.beam) / snd.maxStress, -1, 1) * beamVel * beamVel -- find the stress on the current sound beam (unsmoothed)
getBeamStressDamp(*)
:
[object Object]
getBeamVectorFromNode(*)
[3]
0
:
local vectorUp = vec3(obj:getBeamVectorFromNode(stabilizationBeams.bottomTop, stabilizationNodes.bottomCenter)):normalized()
1
:
local vectorUp = vec3(obj:getBeamVectorFromNode(stabilizationBeams.bottomTop, stabilizationNodes.bottomCenter)):normalized()
2
:
local vectorTopLeft = vec3(obj:getBeamVectorFromNode(stabilizationBeams.centerLeft, stabilizationNodes.topCenter)):normalized()
getBeamVelocity(*)
[1]
0
:
local beamVel = min(1, abs(obj:getBeamVelocity(snd.beam)))
getCameraPosition(*)
:
[object Object]
getCollidableTriangleCount(*)
[1]
0
:
collidable_tri_count = obj:getCollidableTriangleCount(),
getCornerPosition(*)
:
[object Object]
getDensityAtNode(*)
:
[object Object]
getDirection(*)
[1]
0
:
local rotation = math.deg(obj:getDirection()) + 180
getDirectionVector(*)
[3]
0
:
local vectorForward = obj:getDirectionVector()
1
:
local aiDirVec = vec3(obj:getDirectionVector())
2
:
aiDirVec:set(obj:getDirectionVector())
getDirectionVectorRight(*)
:
[object Object]
getDirectionVectorUp(*)
[3]
0
:
local vectorUp = obj:getDirectionVectorUp()
1
:
local ai = {prevDirVec = vec3(aiDirVec), upVec = vec3(obj:getDirectionVectorUp()), rightVec = vec3(), width = nil, length = nil}
2
:
ai.upVec:set(obj:getDirectionVectorUp())
getDissipatedEnergy(*)
:
[object Object]
getDistanceFromTerrain(*)
:
[object Object]
getDistanceFromTerrainPoint(*)
[1]
0
:
obj.debugDrawProxy:drawText2D(float3(40,20,0), color(0,0,0,255), "COG distance above ground: " .. string.format("%0.3f m", obj:getDistanceFromTerrainPoint(p)))
getEnvPressure(*)
:
[object Object]
getEnvTemperature(*)
[3]
0
:
tEnv = obj:getEnvTemperature() + conversion.kelvinToCelsius
1
:
tEnv = obj:getEnvTemperature() + conversion.kelvinToCelsius
2
:
tEnv = obj:getEnvTemperature() + conversion.kelvinToCelsius
getFlow(*)
:
[object Object]
getForwardVector(*)
:
[object Object]
getFrontAirflowSpeed(*)
[2]
0
:
local airSpeedThroughVehicle = abs(obj:getFrontAirflowSpeed())
1
:
local airSpeedThroughVehicle = abs(obj:getFrontAirflowSpeed())
getFrontPosition(*)
[3]
0
:
local aiPos = vec3(obj:getFrontPosition())
1
:
local tmpPos = obj:getFrontPosition()
2
:
local pos = vec3(obj:getFrontPosition())
getFrontPositionRelative(*)
[2]
0
:
pos = p1 - dir * vec3(obj:getFrontPositionRelative()):dot(vec3(obj:getDirectionVector()))
1
:
pos = p1 - dir * vec3(obj:getFrontPositionRelative()):dot(vec3(obj:getDirectionVector()))
getGravity(*)
[3]
0
:
local g = abs(obj:getGravity())
1
:
local acc = sensors.gy2 / obj:getGravity()
2
:
lsensors.gravity = obj:getGravity()
getGravityVector(*)
[1]
0
:
local grleft = left:dot(vec3(obj:getGravityVector()))
getGroundModelId(*)
:
[object Object]
getGroundSpeed(*)
[3]
0
:
vals.airspeed = obj:getGroundSpeed()
1
:
local groundSpeed = obj:getGroundSpeed()
2
:
-- if obj:getGroundSpeed() > 15 then
getGroupPressure(*)
[1]
0
:
wheelData.pressure = hasPressure and obj:getGroupPressure(v.data.pressureGroups[wd.pressureGroup]) * 0.000145038 or 0
getHydroDisplacement(*)
:
[object Object]
getHydroDisplacementFrom(*)
:
[object Object]
getID(*)
[3]
0
:
BeamEngine:queueAllObjectLua("beamstate.setCouplerVisiblityExternal(" .. tostring(obj:getID()) .. "," .. tostring(visible) .. ")")
1
:
obj:queueGameEngineLua(string.format("onCouplerDetach(%s,%s)", obj:getID(), val.cid))
2
:
--print(string.format("coupler found %s.%s->%s.%s", obj:getID(),nodeId,obj2id, obj2nodeId))
getId(*)
[2]
0
:
obj:queueGameEngineLua(string.format(callback, obj:getId(), dumps(cOff)))
1
:
objectId = obj:getId() -- also set by c++
getImpactDeformEnergyNode(*)
[1]
0
:
local impactEnergy, breakEnergy, breakNode, mat1, mat2 = obj:getImpactDeformEnergyNode()
getInitialLength(*)
[1]
0
:
ai.length = ai.length or obj:getInitialLength()
getInitialQuaternion(*)
:
[object Object]
getInitialWidth(*)
[1]
0
:
ai.width = ai.width or obj:getInitialWidth()
getMeshesContainingMaterial(*)
:
[object Object]
getMeshsMaterials(*)
:
[object Object]
getNodeCount(*)
:
[object Object]
getNodeForce(*)
[1]
0
:
t = min(max(obj:getNodeForce(thruster.id1, thruster.id2), 0) + t, thruster.thrustLimit)
getNodeForceNonInertial(*)
[1]
0
:
local oilpanForceZ, oilpanForceXY = obj:getNodeForceNonInertial(oilpanNodeBottom, oilpanNodeTop)
getNodeForceNonInertialZ(*)
:
[object Object]
getNodeForceOnBeamDir(*)
:
[object Object]
getNodeForceVector(*)
[3]
0
:
local frc = vec3(obj:getNodeForceVector(node.cid))
1
:
local frc = vec3(obj:getNodeForceVector(node.cid))
2
:
local fa = vec3(obj:getNodeForceVector(imu.a)) * imu.u
getNodeForceVectorNonInertialXYZ(*)
[1]
0
:
-- local accVector = -vec3(obj:getNodeForceVectorNonInertialXYZ(stabilizationNodes.bottomCenter)):normalized()
getNodeFrictionCoef(*)
:
[object Object]
getNodeMass(*)
[3]
0
:
local nodeWeight = obj:getNodeMass(node.cid)
1
:
local modeVal = obj:getNodeMass(node.cid)
2
:
w = w + obj:getNodeMass(node.cid)
getNodePosition(*)
[3]
0
:
local pos1 = vec3(obj:getNodePosition(wd.node1) + obj:getPosition())
1
:
local pos2 = vec3(obj:getNodePosition(wd.node2) + obj:getPosition())
2
:
vec3(obj:getNodePosition(node.cid)):toTable()
getNodePositionRelative(*)
:
[object Object]
getNodePositionRelativeXYZ(*)
:
[object Object]
getNodeSlidingFrictionCoef(*)
:
[object Object]
getNodeVelocity(*)
[1]
0
:
local vel = -obj:getNodeVelocity(thruster.id2, thruster.id1)
getNodeVelocityVector(*)
[3]
0
:
local modeVal = vec3(obj:getNodeVelocityVector(node.cid)) - vecVel
1
:
local vel = vec3(obj:getNodeVelocityVector(node.cid)) - vecVel
2
:
ballCenterVelocity = vec3(obj:getNodeVelocityVector(ballCenterNode))
getNodesVector(*)
[2]
0
:
forceVectorFront = vec3(obj:getNodesVector(stabilizationNodes.topCenter, stabilizationNodes.topFront)):normalized() * frontRearForceCoef * forceMultiplier
1
:
forceVectorLeft = vec3(obj:getNodesVector(stabilizationNodes.topCenter, stabilizationNodes.topLeft)):normalized() * leftRightForceCoef * forceMultiplier
getObjectCollisionIds(*)
[1]
0
:
obj:getObjectCollisionIds(objCols)
getObjectFrontPosition(*)
[2]
0
:
local posFront = obj:getObjectFrontPosition(plID)
1
:
local plPosFront = vec3(obj:getObjectFrontPosition(plID))
getObjectInitialLength(*)
[1]
0
:
v.length = obj:getObjectInitialLength(plID) + 0.3
getObjectInitialWidth(*)
[2]
0
:
v.width = obj:getObjectInitialWidth(plID)
1
:
aiWidth = obj:getObjectInitialWidth(objectId)
getOriginalNodeMass(*)
[1]
0
:
if math.abs(obj:getOriginalNodeMass(node.cid) - obj:getNodeMass(node.cid)) > 0.1 then
getOriginalNodePositionRelative(*)
[3]
0
:
local p1 = vec3(obj:getOriginalNodePositionRelative(t.id1))
1
:
local p2 = vec3(obj:getOriginalNodePositionRelative(t.id2))
2
:
local p3 = vec3(obj:getOriginalNodePositionRelative(t.id3))
getPhysicsDt(*)
[1]
0
:
physicsDt = obj:getPhysicsDt()
getPhysicsFPS(*)
:
[object Object]
getPitchAngularVelocity(*)
[1]
0
:
local pitchRate = obj:getPitchAngularVelocity()
getPosition(*)
[3]
0
:
--local cog = vec3(obj:calcCenterOfGravityRel(true)) + obj:getPosition()
1
:
local copVec = vec3(obj:calcCenterOfPressureRel() + obj:getPosition())
2
:
local pos1 = vec3(obj:getNodePosition(wd.node1) + obj:getPosition())
getPositionXYZ(*)
[3]
0
:
lp.x, lp.y, lp.z = obj:getPositionXYZ()
1
:
o.posX, o.posY, o.posZ = obj:getPositionXYZ()
2
:
objPosition = vec3(obj:getPositionXYZ())
getProjectedNodePosition(*)
:
[object Object]
getRealdt(*)
[2]
0
:
recoverTimer = recoverTimer + obj:getRealdt()
1
:
local realDt = obj:getRealdt()
getRelativeAirDensity(*)
[1]
0
:
device.intakeAirDensityCoef = obj:getRelativeAirDensity()
getRollAngularVelocity(*)
[1]
0
:
local rollRate = obj:getRollAngularVelocity()
getRollPitchYaw(*)
[1]
0
:
lsensors.roll,lsensors.pitch, lsensors.yaw = obj:getRollPitchYaw()
getRollPitchYawAngularVelocity(*)
:
[object Object]
getRotation(*)
[1]
0
:
local pos = (quat(obj:getRotation()) * imu.pos + vec3(obj:getPosition())):toFloat3()
getSafeLocalQueueNumber(*)
:
[object Object]
getSelfCollisionMode(*)
:
[object Object]
getSelfCollisionState(*)
:
[object Object]
getSensorVectorRaw(*)
:
[object Object]
getSensorX(*)
[1]
0
:
local accXRaw = -obj:getSensorX()
getSensorY(*)
[1]
0
:
local accYRaw = -obj:getSensorY()
getSensorZ(*)
[1]
0
:
local accZRaw = -obj:getSensorZ()
getSensorZnonInertial(*)
:
[object Object]
getSimulationTimeScale(*)
[1]
0
:
return obj:getSimulationTimeScale()
getStaticFrictionCoef(*)
[1]
0
:
staticFrictionCoef = 0.95 * obj:getStaticFrictionCoef()
getSurfaceHeightBelow(*)
[3]
0
:
-- aiPos.z = obj:getSurfaceHeightBelow(cgPos)
1
:
aiPos.z = max(aiPos.z - 1, obj:getSurfaceHeightBelow(tmpPos))
2
:
p1.z = obj:getSurfaceHeightBelow(posf3)
getSwitchableMaterial(*)
:
[object Object]
getTerrainDrivability(*)
:
[object Object]
getTerrainHeight(*)
:
[object Object]
getTerrainNormal(*)
:
[object Object]
getTorsionbarAngle(*)
:
[object Object]
getTriangleCount(*)
[1]
0
:
tri_count = obj:getTriangleCount(),
getUpdateUIflag(*)
[3]
0
:
if playerInfo.anyPlayerSeated and obj:getUpdateUIflag() then
1
:
if streams.hasActiveStreams() and obj:getUpdateUIflag() then
2
:
if playerInfo.anyPlayerSeated and obj:getUpdateUIflag() then
getVelocity(*)
[3]
0
:
local aiVel = vec3(obj:getVelocity())
1
:
aiVel:set(obj:getVelocity())
2
:
targetSpeedSmoother = newTemporalSmoothingNonLinear(math.huge, 0.2, vec3(obj:getVelocity()):length())
getWheel(*)
[1]
0
:
local wobj = obj:getWheel(wd.wheelID)
getYawAngularVelocity(*)
[3]
0
:
yawRate = yawSmooth:get(-obj:getYawAngularVelocity())
1
:
local yawRate = obj:getYawAngularVelocity()
2
:
local yawRate = yawSmoother:get(-obj:getYawAngularVelocity())
hasNodeCollidedDuring(*)
:
[object Object]
inWater(*)
[3]
0
:
local inWater = obj:inWater(node.cid)
1
:
isFlooding = isFlooding and obj:inWater(n)
2
:
local exhaustNodeInWater = obj:inWater(n.finish)
initLuaCallbacks(*)
:
[object Object]
isNodeColliding(*)
[1]
0
:
isTouchingGround = isTouchingGround or obj:isNodeColliding(nodeCid)
nodeDot(*)
:
[object Object]
nodeLength(*)
[2]
0
:
wheelBase = obj:nodeLength(wheelCache[frontRightWheelId].node1, wheelCache[rearRightWheelId].node1) --calculate wheelbase from the distance of the front and rear wheels
1
:
local dist = obj:nodeLength(currentNodeKey, hotcid) --distance to nearby nodes, for heat radiation
nodeLineSectionDistance(*)
[1]
0
:
wd.lastTreadContactNode and obj:nodeLineSectionDistance(wd.lastTreadContactNode, wd.node1, wd.node2) or wd.radius, dt)
nodeSquaredLength(*)
[1]
0
:
local squareDistance = obj:nodeSquaredLength(k, cid)
nodeVecCos(*)
[2]
0
:
--local camberSign = obj:nodeVecCos(wd.node2, wd.node2, vectorForward) --unused
1
:
local toeSign = obj:nodeVecCos(wd.node1, wd.node2, vectorForward)
nodeVecPlanarCos(*)
[3]
0
:
wheelData.caster = deg(acos(obj:nodeVecPlanarCos(wd.steerAxisUp, wd.steerAxisDown, vectorUp, vectorForward)))
1
:
wheelData.sai = deg(acos(obj:nodeVecPlanarCos(wd.steerAxisUp, wd.steerAxisDown, vectorUp, vectorRight)))
2
:
wheelData.camber = (90 - deg(acos(obj:nodeVecPlanarCos(wd.node2, wd.node1, vectorUp, vectorRight))))
nodeVecPlanarCosRightForward(*)
[2]
0
:
wheelAngleFront = acos(obj:nodeVecPlanarCosRightForward(wheelFront.node1, wheelFront.node2))
1
:
wheelAngleRear = acos(obj:nodeVecPlanarCosRightForward(wheelRear.node1, wheelRear.node2))
nodeVecPlanarSinForward2(*)
:
[object Object]
playRPMLeds(*)
[1]
0
:
obj:playRPMLeds(engine.outputAV1 or 0, (engine.maxAV or 1) * 0.8, engine.maxAV or 1) -- currentValue, firstLEDValue, lastLEDValue)
playSFX(*)
[3]
0
:
obj:playSFX(device.engineMiscSounds.shutOffSoundEngine)
1
:
obj:playSFX(device.engineMiscSounds.shutOffSoundExhaust)
2
:
obj:playSFX(device.engineMiscSounds.starterSoundEngine)
playSFXOnce(*)
[2]
0
:
obj:playSFXOnce(soundEvent, soundNode, intensity, 1)
1
:
obj:playSFXOnce(device.gearGrindSoundFile, device.transmissionNodeID or sounds.engineNode, min(max(avDifference / 80, 0), 5), min(max(avDifference / 20, 0.95), 1.1))
playSFXOnceCT(*)
[3]
0
:
obj:playSFXOnceCT(afterFire.instantAudioSample, n.finish, n.afterFireVolumeCoef * afterFire.instantVolumeCoef, 1.0, 1 - n.afterFireMufflingCoef, 0)
1
:
obj:playSFXOnceCT(afterFire.shiftAudioSample, n.finish, n.afterFireVolumeCoef * afterFire.shiftVolumeCoef, 1.0, 1 - n.afterFireMufflingCoef, 0)
2
:
obj:playSFXOnceCT(afterFire.sustainedAudioSample, n.finish, n.afterFireVolumeCoef * afterFire.sustainedVolumeCoef, 1.0, 1 - n.afterFireMufflingCoef, 0)
playSFXOnceStatic(*)
:
[object Object]
playSFXOnceStaticCT(*)
[1]
0
:
obj:playSFXOnceStaticCT(soundName, nodeID, volume, pitch, color or 0, texture or 0)
propUpdate(*)
[1]
0
:
obj:propUpdate(prop.pid, pt.x, pt.y, pt.z, pr.x, pr.y, pr.z, not prop.hidden, val, min(max(val * prop.multiplier, prop.min), prop.max) + prop.offset)
queueGameEngineLua(*)
[3]
0
:
obj:queueGameEngineLua(string.format("extensions.ui_uinavi.requestVehicleDashboardMap(%q)", screenMaterialName))
1
:
obj:queueGameEngineLua(string.format("onObjectCouplingChange(%s,%s)", objectId, serialize(attachedCouplers)))
2
:
obj:queueGameEngineLua(string.format("onCouplerDetach(%s,%s)", obj:getID(), val.cid))
queueHookJS(*)
:
[object Object]
queueLuaCommand(*)
:
[object Object]
queueObjectLuaCommand(*)
[3]
0
:
obj:queueObjectLuaCommand(obj2id, "beamstate.exportCouplerData(" .. tostring(obj2nodeId) .. ", " .. serialize(data) .. ")")
1
:
obj:queueObjectLuaCommand(coupler.obj2id, string.format("beamstate.importCouplerData(%s, %s)", coupler.obj2nodeId, serialize(data)))
2
:
obj:queueObjectLuaCommand(objID, string.format("%s(%q)", callback, jsonEncode(chassisData)))
queueStreamDataJS(*)
:
[object Object]
queueWebViewJS(*)
[1]
0
:
obj:queueWebViewJS(webViewTag, jsCmd)
requestReset(*)
[3]
0
:
obj:requestReset(RESET_PHYSICS)
1
:
obj:requestReset(RESET_PHYSICS) -- fix vehicle + reset velocity
2
:
obj:requestReset(RESET_PHYSICS)
resetMaterials(*)
[3]
0
:
obj:resetMaterials(msc)
1
:
obj:resetMaterials(msc)
2
:
obj:resetMaterials(mid)
respawnWithPartConfig(*)
:
[object Object]
sendForceFeedback(*)
[3]
0
:
obj:sendForceFeedback(FFBID, newForceAtDriver)
1
:
obj:sendForceFeedback(FFBID, 0)
2
:
obj:sendForceFeedback(FFBID, 0)
sendRPMLeds(*)
[1]
0
:
obj:sendRPMLeds(FFBID, currentRPM, rpmFirstLedTurnsOn, rpmRedLine)
setAerodynamicsMode(*)
[2]
0
:
obj:setAerodynamicsMode(2)
1
:
obj:setAerodynamicsMode(1)
setBeam(*)
:
[object Object]
setBeamAnisotropic(*)
[1]
0
:
obj:setBeamAnisotropic(bid, 0, 0, 0, longBound)
setBeamBounded(*)
:
[object Object]
setBeamDeformationTriggerRatio(*)
:
[object Object]
setBeamLbeam(*)
:
[object Object]
setBeamLength(*)
[2]
0
:
obj:setBeamLength(cid, beam[1])
1
:
obj:setBeamLength(cid, obj:getBeamLength(cid))
setBeamLengthRefRatio(*)
[1]
0
:
obj:setBeamLengthRefRatio(beamData.cid, beamData.currentPosition)
setBeamLengthRefRatioTarget(*)
:
[object Object]
setBeamPressureRel(*)
[2]
0
:
obj:setBeamPressureRel(beamcid, 0, math.huge, -1, -1)
1
:
obj:setBeamPressureRel(cid, pressurePSI * psiToPascal, maxPressure * psiToPascal, spring, damp)
setBeamPressured(*)
:
[object Object]
setBeamSpringDamp(*)
[3]
0
:
obj:setBeamSpringDamp(beamcid, v.data.beams[beamcid].beamSpring * 0.05, 0, -1, -1)
1
:
obj:setBeamSpringDamp(beamcid, v.data.beams[beamcid].beamSpring * 0.05, 0, -1, -1)
2
:
--obj:setBeamSpringDamp(beamcid, v.data.beams[beamcid].beamSpring * 0.05, 0, -1, -1)
setBoundedBeamDamp(*)
[1]
0
:
obj:setBoundedBeamDamp(cid, beamDamp, beamDampRebound, beamDampFast, beamDampReboundFast, beamDampVelocitySplit)
setDebugString(*)
:
[object Object]
setEngineSound(*)
[3]
0
:
obj:setEngineSound(device.engineSoundID, rpm, scaledEngineLoad, fundamentalFreq, volumeCoef)
1
:
obj:setEngineSound(device.engineSoundIDExhaust, rpm, scaledEngineLoadExhaust, fundamentalFreqExhaust, volumeCoef)
2
:
obj:setEngineSound(device.engineSoundID, rpm, engineLoad, fundamentalFreq, device.engineVolumeCoef)
setGravity(*)
:
[object Object]
setGroupPressure(*)
[1]
0
:
obj:setGroupPressure(v.data.pressureGroups[wheel.pressureGroup], (0.2 * 6894.757 + 101325))
setGroupPressureRel(*)
[2]
0
:
obj:setGroupPressureRel(v.data.pressureGroups["ball"], unCrouchingPressureRatio)
1
:
obj:setGroupPressureRel(v.data.pressureGroups["ball"], ballPressureCrouch)
setNode(*)
[1]
0
:
obj:setNode(node.cid, pos.x, pos.y, pos.z, nodeWeight, ntype, frictionCoef, slidingFrictionCoef, node.stribeckExponent or 1.75, node.stribeckVelMult or 1, noLoadCoef, fullLoadCoef, loadSensitivitySlope, node.softnessCoef or 0.5, node.treadCoef or 0.5, node.tag or '', node.couplerStrength or math.huge, node.firstGroup or -1, selfCollision, collision, staticCollision, nodeMaterialTypeID)
setNodeFrictionSlidingCoefs(*)
[1]
0
:
-- -- --obj:setNodeFrictionSlidingCoefs(v.cid, v.frictionCoef * frictionAdjustmentCoef, v.slidingFrictionCoef * frictionAdjustmentCoef)
setNodeMass(*)
[3]
0
:
obj:setNodeMass(cid, node[2])
1
:
obj:setNodeMass(k, v + storage.storedEnergy * storage.fuelNodeMassCoef)
2
:
obj:setNodeMass(k, v + storage.storedEnergy * storage.fuelNodeMassCoef)
setNodeMaterial(*)
:
[object Object]
setNodePair(*)
:
[object Object]
setNodePair2WheelId(*)
[1]
0
:
obj:setNodePair2WheelId(node.cid, node.pairedNode, node.pairedNode2 or -1, node.wheelID or -1)
setNodePosition(*)
[1]
0
:
obj:setNodePosition(cid, vec3(node[1]):toFloat3())
setNodeVolumePitchCT(*)
[2]
0
:
obj:setNodeVolumePitchCT(fireBurnSoundObj, hotcid, x * (0.5*x + 0.5), 1, 0, 0)
1
:
obj:setNodeVolumePitchCT(event, p.id1, slipVel * normalForce / (normalForce + 6) * 8000, slipVel * 0.01, normalForce, max(scrapeLoosenessMap[p.materialID1] or 0, scrapeLoosenessMap[p.materialID2] or 0))
setPersistentData(*)
[1]
0
:
obj:setPersistentData(serialize(d))
setPhysicsStepEnabled(*)
:
[object Object]
setPitch(*)
:
[object Object]
setPlanets(*)
[3]
0
:
obj:setPlanets(planets)
1
:
obj:setPlanets(planets)
2
:
obj:setPlanets(planets)
setPrecompressionRatio(*)
[1]
0
:
obj:setPrecompressionRatio(b.cid, 1 + (b.beamPrecompression - 1) * min(tratio, 1))
setReferenceNodes(*)
[1]
0
:
obj:setReferenceNodes(
setSFXNode(*)
:
[object Object]
setSFXparameter(*)
[1]
0
:
obj:setSFXparameter(self.obj, keyName, value)
setSelfCollisionMode(*)
[2]
0
:
obj:setSelfCollisionMode(2)
1
:
obj:setSelfCollisionMode(1)
setSimulationTimeScale(*)
:
[object Object]
setSleepingEnabled(*)
[1]
0
:
obj:setSleepingEnabled(false)
setTorsionbar(*)
[1]
0
:
tb.cid = obj:setTorsionbar(-1, id1, id2, id3, id4, spring, damp,
setTorsionbarAngle(*)
:
[object Object]
setTorsionbarSpringDamp(*)
[1]
0
:
obj:setTorsionbarSpringDamp(cid, spring, damp)
setTriangle(*)
[1]
0
:
triangle.cid = obj:setTriangle(-1, triangle.id1, triangle.id2, triangle.id3, dragCoef/100, liftCoef/100,
setVolume(*)
[3]
0
:
obj:setVolume(device.engineMiscSounds.starterSoundEngine, device.engineMiscSounds.starterVolume)
1
:
obj:setVolume(device.engineMiscSounds.starterSoundExhaust, device.engineMiscSounds.starterVolumeExhaust)
2
:
obj:setVolume(device.engineMiscSounds.shutOffSoundEngine, device.engineMiscSounds.shutOffVolumeEngine)
setVolumePitch(*)
[3]
0
:
obj:setVolumePitch(pumpSoundLoop, volume, pitch)
1
:
obj:setVolumePitch(releaseSoundLoop, volume, 1)
2
:
obj:setVolumePitch(releaseSoundLoop, 0, 0)
setVolumePitchCT(*)
[3]
0
:
obj:setVolumePitchCT(self.obj, vol, pitch, color, texture)
1
:
obj:setVolumePitchCT(bovSound, bovVolume, 1, bovSoundVolumeCoef, 0)
2
:
obj:setVolumePitchCT(flutterSound, flutterVolume, 1, flutterSoundVolumeCoef, 0)
setWaterFlow(*)
:
[object Object]
setWheel(*)
[1]
0
:
local wid = obj:setWheel(wheel.cid, wheel.numRays or -1, wheel.node1, wheel.node2, wheel.nodeArm or -1,
setWheelTorqueAndBrakeTorque(*)
[1]
0
:
obj:setWheelTorqueAndBrakeTorque(wd.cid, 0, 0)
setWind(*)
[3]
0
:
--obj:setWind(0,55.55,0)
1
:
--obj:setWind(0,0,55.55)
2
:
obj:setWind(forceVec.x, forceVec.y, forceVec.z)
stopLatching(*)
[1]
0
:
obj:stopLatching()
stopSFX(*)
[3]
0
:
obj:stopSFX(device.engineMiscSounds.starterSoundEngine)
1
:
obj:stopSFX(device.engineMiscSounds.starterSoundExhaust)
2
:
obj:stopSFX(device.engineMiscSounds.starterSoundEngine)
switchMaterial(*)
[2]
0
:
obj:switchMaterial(msc, matname)
1
:
obj:switchMaterial(msc, newMat)
torsionbarIsBroken(*)
:
[object Object]
wheelTurnRadius(*)
[2]
0
:
local leftDist = obj:wheelTurnRadius(frontLeftWheel.wheelID, rearLeftWheel.wheelID)
1
:
local rightDist = obj:wheelTurnRadius(frontRightWheel.wheelID, rearRightWheel.wheelID)
objectId
[3]
0
:
if k ~= objectId then
1
:
if k ~= objectId and v.active == true then
2
:
if plID ~= objectId then
os
{11}
clock(*)
:
[object Object]
date(*)
[3]
0
:
data.time = os.date("%H") .. ":" .. os.date("%M") -- done to prevent seconds from being sent.
1
:
--data.time = os.date("%H") .. ":" .. os.date("%M") -- done to prevent seconds from being sent.
2
:
return string.format('%s%05d==%05u', os.date('%d%m%Y%H%M%S'),
difftime(*)
:
[object Object]
execute(*)
:
[object Object]
exit(*)
:
[object Object]
getenv(*)
[2]
0
:
if not outfile then outfile = os.getenv("LUAJIT_PROFILEFILE")
1
:
if not outfile then outfile = os.getenv("LUAJIT_VERBOSEFILE")
remove(*)
:
[object Object]
rename(*)
:
[object Object]
setlocale(*)
:
[object Object]
time(*)
[3]
0
:
math.randomseed(os.time())
1
:
math.randomseed(os.time())
2
:
return "LuaSoundProfile" .. sfxprofilecounter .. "_" .. os.time()
tmpname(*)
:
[object Object]
partCondition
{5}
getConditions()
[1]
0
:
local vehicleState = {objId = obj:getID(), partsCondition = partCondition.getConditions(), itemId = v.config.itemId, pos = pos, front = front, up = up}
init()
[1]
0
:
partCondition.init()
initConditions(partsCondition)
:
[object Object]
reset()
[1]
0
:
partCondition.reset()
test(odometer, integrityValue)
:
[object Object]
particlefilter
{1}
nodeCollision(p)
[1]
0
:
particlefilter.nodeCollision(p)
particles
{3}
getMaterialByID(mats, i)
:
[object Object]
getMaterialIDByName(mats, s)
[1]
0
:
ival = particles.getMaterialIDByName(materials, valuePart:sub(4))
getMaterialsParticlesTable()
[3]
0
:
materials = particles.getMaterialsParticlesTable()
1
:
local materials, materialsMap = particles.getMaterialsParticlesTable()
2
:
local materials, materialsMap = particles.getMaterialsParticlesTable()
path
{8}
dirname(filename)
:
[object Object]
getCurrentPath()
:
[object Object]
getPathLevelInfo(levelName)
:
[object Object]
getPathLevelMain(levelName)
:
[object Object]
is_file(filename)
:
[object Object]
levelFromPath(filepath)
:
[object Object]
split(path, compositeExtension)
[3]
0
:
local _, fileNameWithExt, _ = path.split(file)
1
:
local _, _, ext = path.split(filename)
2
:
local _, file, _ = path.split(filePath)
splitWithoutExt(filepath, compositeExtension)
[1]
0
:
local _, configName = path.splitWithoutExt(v.config.partConfigFilename)
physicsDt
[3]
0
:
local physicsDt = physicsDt
1
:
local invPhysSteps = physicsDt / dt
2
:
h._inrate = h.inRate * physicsDt
playerInfo
{3}
anyPlayerSeated
[3]
0
:
if playerInfo.anyPlayerSeated then
1
:
if updateTimer > invFPS and playerInfo.anyPlayerSeated then
2
:
if playerInfo.anyPlayerSeated and obj:getUpdateUIflag() then
firstPlayerSeated
[3]
0
:
if not playerInfo.firstPlayerSeated then return
1
:
if not playerInfo.firstPlayerSeated then
2
:
if not playerInfo.firstPlayerSeated then
seatedPlayers
:
[object Object]
powertrain
{33}
cumulativeGearRatio
:
[object Object]
currentGravity
[3]
0
:
local gravityLimit = -3 * powertrain.currentGravity
1
:
oilpanAccZSmoother:set(-powertrain.currentGravity)
2
:
oilpanAccZSmoother:set(-powertrain.currentGravity)
engineData
:
[object Object]
stabilityCoef
[3]
0
:
device.parkLockSpring = device.parkLockSpringBase or (powertrain.stabilityCoef * powertrain.stabilityCoef * outputInertia * 0.5) --Nm/rad
1
:
device.parkLockSpring = device.parkLockSpringBase or (powertrain.stabilityCoef * powertrain.stabilityCoef * outputInertia * 0.5) --Nm/rad
2
:
device.lockSpring1 = device.lockSpringBase or (powertrain.stabilityCoef * powertrain.stabilityCoef * device.cumulativeInertia1) --Nm/rad
torqueReactionCoefs
:
[object Object]
wheels
{4}
FL
{109}
absFrequency
:
[object Object]
absTime
:
[object Object]
absTimer
:
[object Object]
airSpeedCoreCooling
:
[object Object]
angularVelocity
:
[object Object]
angularVelocityBrakeCouple
:
[object Object]
brakeCoolingArea
:
[object Object]
brakeCoreEnergyCoef
:
[object Object]
brakeCoreTemperature
:
[object Object]
brakeDiameter
:
[object Object]
brakeInputSplit
:
[object Object]
brakeMass
:
[object Object]
brakeMeltingPoint
:
[object Object]
brakePressureDelay
{1}
state
:
[object Object]
brakeSpecHeat
:
[object Object]
brakeSplitCoef
:
[object Object]
brakeSquealLoop
{5}
lastColor
:
[object Object]
lastPitch
:
[object Object]
lastTexture
:
[object Object]
lastVol
:
[object Object]
obj
:
[object Object]
brakeSquealVolumeSmoother
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
brakeSurfaceEnergyCoef
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
brakeTorque
:
[object Object]
brakeType
:
[object Object]
brakeTypeCoreCoolingCoef
:
[object Object]
brakeTypeSurfaceCoolingCoef
:
[object Object]
brakeVentingCoef
:
[object Object]
brakingTorque
:
[object Object]
cid
:
[object Object]
contactDepth
:
[object Object]
contactMaterialID1
:
[object Object]
contactMaterialID2
:
[object Object]
coreData
:
[object Object]
deflatedTireAngle
:
[object Object]
desiredBrakingTorque
:
[object Object]
downForce
:
[object Object]
downForceRaw
:
[object Object]
downForceSmoother
{1}
state
:
[object Object]
dynamicRadius
:
[object Object]
dynamicRadiusSmoother
{1}
state
:
[object Object]
enableBrakeThermals
:
[object Object]
flatTireSound
:
[object Object]
frictionTorque
:
[object Object]
hasABS
:
[object Object]
hasTire
:
[object Object]
hubRadius
:
[object Object]
inertia
:
[object Object]
initialBrakeTorque
:
[object Object]
initialParkingTorque
:
[object Object]
invInitialBrakeTorque
:
[object Object]
invRelativeBrakingTorqueCoef
:
[object Object]
isBrakeMolten
:
[object Object]
isBroken
:
[object Object]
isPropulsed
:
[object Object]
isSpeedo
:
[object Object]
isTireDeflated
:
[object Object]
kRadiationToAir
:
[object Object]
kSurfaceToCore
:
[object Object]
lastAngularVelocity
:
[object Object]
lastAngularVelocityBrakeCouple
:
[object Object]
lastSlip
:
[object Object]
lastSlipError
:
[object Object]
lastTorqueMode
:
[object Object]
minABSCoef
:
[object Object]
name
:
[object Object]
node1
:
[object Object]
node2
:
[object Object]
obj
{8}
getPeakPeriod(*)
[2]
0
:
if peakForce > 0 and wd.obj:getPeakPeriod() * vehicleSpeed > 0.0 then
1
:
-- if wd.name == "FL" then print (string.format("peakForce=%6.0f / wd.obj:getPeakPeriod()=%0.2f / vehicleSpeed=%0.3f", peakForce, wd.obj:getPeakPeriod(), vehicleSpeed));
getSlipEnergy(*)
:
[object Object]
getSlipVelEnergy(*)
:
[object Object]
getSlipVelEnergyDownPeakForce(*)
[1]
0
:
wd.lastSlip, wd.slipEnergy, wd.downForceRaw, wd.peakForce = wd.obj:getSlipVelEnergyDownPeakForce()
isRotatingBrakeCouple(*)
[1]
0
:
local isRotatingBrakeCouple = wd.obj:isRotatingBrakeCouple() --0,1 coef based on instability detection of the wheel AV inside the core
setBrakeSpring(*)
[1]
0
:
wobj:setBrakeSpring(max(wd.brakeTorque or 0, wd.parkingTorque or 0, 1) * (wd.brakeSpring or 10))
setEngineAxisCoupleNodes(*)
[1]
0
:
wheel.obj:setEngineAxisCoupleNodes(reactionNodes[1], reactionNodes[2], reactionNodes[3])
setTorqueAndBrakeTorque(*)
:
[object Object]
oppositeSide
:
[object Object]
ownSide
:
[object Object]
padGlazingFactor
:
[object Object]
padMaterial
:
[object Object]
parkingTorque
:
[object Object]
peakForce
:
[object Object]
pressureGroup
:
[object Object]
propulsionTorque
:
[object Object]
radius
:
[object Object]
rayCount
:
[object Object]
rimAirTemperature
:
[object Object]
rimEnergyCoef
:
[object Object]
rimTemperature
:
[object Object]
rotatorType
:
[object Object]
rotorMaterial
:
[object Object]
slipEnergy
:
[object Object]
slipErrorIntegral
:
[object Object]
slipRatioTarget
:
[object Object]
smokeParticleTick
:
[object Object]
softnessCoef
:
[object Object]
squealCoefGlazing
:
[object Object]
squealCoefLowSpeed
:
[object Object]
squealCoefNatural
:
[object Object]
steamParticleTick
:
[object Object]
thermalEfficiencyConfig
{5}
a
:
[object Object]
b1
:
[object Object]
b2
:
[object Object]
w1x1Coef
:
[object Object]
w2x1Coef
:
[object Object]
tireAirEnergyCoef
:
[object Object]
tireAirTemperature
:
[object Object]
tireVolume
:
[object Object]
tireWidth
:
[object Object]
torsionReactor
{31}
children
:
[object Object]
connectedChildrenCount
:
[object Object]
cumulativeGearRatio
:
[object Object]
cumulativeInertia
:
[object Object]
deviceCategories
{1}
shaft
:
[object Object]
friction
:
[object Object]
gearRatio
:
[object Object]
inputAV
:
[object Object]
inputIndex
:
[object Object]
inputName
:
[object Object]
invCumulativeInertia
:
[object Object]
isBroken
:
[object Object]
isPhysicallyDisconnected
:
[object Object]
isPropulsed
:
[object Object]
maxCumulativeGearRatio
:
[object Object]
name
[3]
0
:
if not torsionReactorIndexes[rotator.torsionReactor.name] then
1
:
torsionReactorIndexes[rotator.torsionReactor.name] = torsionReactorCount
2
:
local trIdx = torsionReactorIndexes[rotator.torsionReactor.name]
outputAV1
:
[object Object]
outputPorts
:
[object Object]
outputTorque1
:
[object Object]
parentOutputAVName
:
[object Object]
parentOutputTorqueName
:
[object Object]
torqueReactionNodes
:
[object Object]
type
[2]
0
:
while torsionReactor.parent and torsionReactor.type ~= "torsionReactor" do
1
:
if torsionReactor and torsionReactor.type == "torsionReactor" and torsionReactor.torqueReactionNodes then
uiName
:
[object Object]
visualShaftAVName
:
[object Object]
calculateInertia(device)
:
[object Object]
onBreak()
:
[object Object]
reset(device, jbeamData)
:
[object Object]
torqueUpdate(device)
:
[object Object]
validate(device)
:
[object Object]
velocityUpdate(device, dt)
:
[object Object]
torsionReactorIdx
:
[object Object]
treadCoef
:
[object Object]
treadCoreEnergyCoef
:
[object Object]
treadCoreTemperature
:
[object Object]
treadNodes
:
[object Object]
treadSurfaceEnergyCoef
:
[object Object]
treadSurfaceTemperature
:
[object Object]
wheelDir
:
[object Object]
wheelID
:
[object Object]
wheelSpeed
:
[object Object]
wheelSpeedCoreCooling
:
[object Object]
updateBrake(wd, brake, invAirspeed, airspeed, airspeedCutOff, dt)
:
[object Object]
FR
{109}
absFrequency
:
[object Object]
absTime
:
[object Object]
absTimer
:
[object Object]
airSpeedCoreCooling
:
[object Object]
angularVelocity
:
[object Object]
angularVelocityBrakeCouple
:
[object Object]
brakeCoolingArea
:
[object Object]
brakeCoreEnergyCoef
:
[object Object]
brakeCoreTemperature
:
[object Object]
brakeDiameter
:
[object Object]
brakeInputSplit
:
[object Object]
brakeMass
:
[object Object]
brakeMeltingPoint
:
[object Object]
brakePressureDelay
{1}
state
:
[object Object]
brakeSpecHeat
:
[object Object]
brakeSplitCoef
:
[object Object]
brakeSquealLoop
{5}
lastColor
:
[object Object]
lastPitch
:
[object Object]
lastTexture
:
[object Object]
lastVol
:
[object Object]
obj
:
[object Object]
brakeSquealVolumeSmoother
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
brakeSurfaceEnergyCoef
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
brakeTorque
:
[object Object]
brakeType
:
[object Object]
brakeTypeCoreCoolingCoef
:
[object Object]
brakeTypeSurfaceCoolingCoef
:
[object Object]
brakeVentingCoef
:
[object Object]
brakingTorque
:
[object Object]
cid
:
[object Object]
contactDepth
:
[object Object]
contactMaterialID1
:
[object Object]
contactMaterialID2
:
[object Object]
coreData
:
[object Object]
deflatedTireAngle
:
[object Object]
desiredBrakingTorque
:
[object Object]
downForce
:
[object Object]
downForceRaw
:
[object Object]
downForceSmoother
{1}
state
:
[object Object]
dynamicRadius
:
[object Object]
dynamicRadiusSmoother
{1}
state
:
[object Object]
enableBrakeThermals
:
[object Object]
flatTireSound
:
[object Object]
frictionTorque
:
[object Object]
hasABS
:
[object Object]
hasTire
:
[object Object]
hubRadius
:
[object Object]
inertia
:
[object Object]
initialBrakeTorque
:
[object Object]
initialParkingTorque
:
[object Object]
invInitialBrakeTorque
:
[object Object]
invRelativeBrakingTorqueCoef
:
[object Object]
isBrakeMolten
:
[object Object]
isBroken
:
[object Object]
isPropulsed
:
[object Object]
isSpeedo
:
[object Object]
isTireDeflated
:
[object Object]
kRadiationToAir
:
[object Object]
kSurfaceToCore
:
[object Object]
lastAngularVelocity
:
[object Object]
lastAngularVelocityBrakeCouple
:
[object Object]
lastSlip
:
[object Object]
lastSlipError
:
[object Object]
lastTorqueMode
:
[object Object]
minABSCoef
:
[object Object]
name
:
[object Object]
node1
:
[object Object]
node2
:
[object Object]
obj
{8}
getPeakPeriod(*)
[2]
0
:
if peakForce > 0 and wd.obj:getPeakPeriod() * vehicleSpeed > 0.0 then
1
:
-- if wd.name == "FL" then print (string.format("peakForce=%6.0f / wd.obj:getPeakPeriod()=%0.2f / vehicleSpeed=%0.3f", peakForce, wd.obj:getPeakPeriod(), vehicleSpeed));
getSlipEnergy(*)
:
[object Object]
getSlipVelEnergy(*)
:
[object Object]
getSlipVelEnergyDownPeakForce(*)
[1]
0
:
wd.lastSlip, wd.slipEnergy, wd.downForceRaw, wd.peakForce = wd.obj:getSlipVelEnergyDownPeakForce()
isRotatingBrakeCouple(*)
[1]
0
:
local isRotatingBrakeCouple = wd.obj:isRotatingBrakeCouple() --0,1 coef based on instability detection of the wheel AV inside the core
setBrakeSpring(*)
[1]
0
:
wobj:setBrakeSpring(max(wd.brakeTorque or 0, wd.parkingTorque or 0, 1) * (wd.brakeSpring or 10))
setEngineAxisCoupleNodes(*)
[1]
0
:
wheel.obj:setEngineAxisCoupleNodes(reactionNodes[1], reactionNodes[2], reactionNodes[3])
setTorqueAndBrakeTorque(*)
:
[object Object]
oppositeSide
:
[object Object]
ownSide
:
[object Object]
padGlazingFactor
:
[object Object]
padMaterial
:
[object Object]
parkingTorque
:
[object Object]
peakForce
:
[object Object]
pressureGroup
:
[object Object]
propulsionTorque
:
[object Object]
radius
:
[object Object]
rayCount
:
[object Object]
rimAirTemperature
:
[object Object]
rimEnergyCoef
:
[object Object]
rimTemperature
:
[object Object]
rotatorType
:
[object Object]
rotorMaterial
:
[object Object]
slipEnergy
:
[object Object]
slipErrorIntegral
:
[object Object]
slipRatioTarget
:
[object Object]
smokeParticleTick
:
[object Object]
softnessCoef
:
[object Object]
squealCoefGlazing
:
[object Object]
squealCoefLowSpeed
:
[object Object]
squealCoefNatural
:
[object Object]
steamParticleTick
:
[object Object]
thermalEfficiencyConfig
{5}
a
:
[object Object]
b1
:
[object Object]
b2
:
[object Object]
w1x1Coef
:
[object Object]
w2x1Coef
:
[object Object]
tireAirEnergyCoef
:
[object Object]
tireAirTemperature
:
[object Object]
tireVolume
:
[object Object]
tireWidth
:
[object Object]
torsionReactor
{31}
children
:
[object Object]
connectedChildrenCount
:
[object Object]
cumulativeGearRatio
:
[object Object]
cumulativeInertia
:
[object Object]
deviceCategories
{1}
shaft
:
[object Object]
friction
:
[object Object]
gearRatio
:
[object Object]
inputAV
:
[object Object]
inputIndex
:
[object Object]
inputName
:
[object Object]
invCumulativeInertia
:
[object Object]
isBroken
:
[object Object]
isPhysicallyDisconnected
:
[object Object]
isPropulsed
:
[object Object]
maxCumulativeGearRatio
:
[object Object]
name
[3]
0
:
if not torsionReactorIndexes[rotator.torsionReactor.name] then
1
:
torsionReactorIndexes[rotator.torsionReactor.name] = torsionReactorCount
2
:
local trIdx = torsionReactorIndexes[rotator.torsionReactor.name]
outputAV1
:
[object Object]
outputPorts
:
[object Object]
outputTorque1
:
[object Object]
parentOutputAVName
:
[object Object]
parentOutputTorqueName
:
[object Object]
torqueReactionNodes
:
[object Object]
type
[2]
0
:
while torsionReactor.parent and torsionReactor.type ~= "torsionReactor" do
1
:
if torsionReactor and torsionReactor.type == "torsionReactor" and torsionReactor.torqueReactionNodes then
uiName
:
[object Object]
visualShaftAVName
:
[object Object]
calculateInertia(device)
:
[object Object]
onBreak()
:
[object Object]
reset(device, jbeamData)
:
[object Object]
torqueUpdate(device)
:
[object Object]
validate(device)
:
[object Object]
velocityUpdate(device, dt)
:
[object Object]
torsionReactorIdx
:
[object Object]
treadCoef
:
[object Object]
treadCoreEnergyCoef
:
[object Object]
treadCoreTemperature
:
[object Object]
treadNodes
:
[object Object]
treadSurfaceEnergyCoef
:
[object Object]
treadSurfaceTemperature
:
[object Object]
wheelDir
:
[object Object]
wheelID
:
[object Object]
wheelSpeed
:
[object Object]
wheelSpeedCoreCooling
:
[object Object]
updateBrake(wd, brake, invAirspeed, airspeed, airspeedCutOff, dt)
:
[object Object]
RL
{109}
absFrequency
:
[object Object]
absTime
:
[object Object]
absTimer
:
[object Object]
airSpeedCoreCooling
:
[object Object]
angularVelocity
:
[object Object]
angularVelocityBrakeCouple
:
[object Object]
brakeCoolingArea
:
[object Object]
brakeCoreEnergyCoef
:
[object Object]
brakeCoreTemperature
:
[object Object]
brakeDiameter
:
[object Object]
brakeInputSplit
:
[object Object]
brakeMass
:
[object Object]
brakeMeltingPoint
:
[object Object]
brakePressureDelay
{1}
state
:
[object Object]
brakeSpecHeat
:
[object Object]
brakeSplitCoef
:
[object Object]
brakeSquealLoop
{5}
lastColor
:
[object Object]
lastPitch
:
[object Object]
lastTexture
:
[object Object]
lastVol
:
[object Object]
obj
:
[object Object]
brakeSquealVolumeSmoother
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
brakeSurfaceEnergyCoef
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
brakeTorque
:
[object Object]
brakeType
:
[object Object]
brakeTypeCoreCoolingCoef
:
[object Object]
brakeTypeSurfaceCoolingCoef
:
[object Object]
brakeVentingCoef
:
[object Object]
brakingTorque
:
[object Object]
cid
:
[object Object]
contactDepth
:
[object Object]
contactMaterialID1
:
[object Object]
contactMaterialID2
:
[object Object]
coreData
:
[object Object]
deflatedTireAngle
:
[object Object]
desiredBrakingTorque
:
[object Object]
downForce
:
[object Object]
downForceRaw
:
[object Object]
downForceSmoother
{1}
state
:
[object Object]
dynamicRadius
:
[object Object]
dynamicRadiusSmoother
{1}
state
:
[object Object]
enableBrakeThermals
:
[object Object]
flatTireSound
:
[object Object]
frictionTorque
:
[object Object]
hasABS
:
[object Object]
hasTire
:
[object Object]
hubRadius
:
[object Object]
inertia
:
[object Object]
initialBrakeTorque
:
[object Object]
initialParkingTorque
:
[object Object]
invInitialBrakeTorque
:
[object Object]
invRelativeBrakingTorqueCoef
:
[object Object]
isBrakeMolten
:
[object Object]
isBroken
:
[object Object]
isPropulsed
:
[object Object]
isSpeedo
:
[object Object]
isTireDeflated
:
[object Object]
kRadiationToAir
:
[object Object]
kSurfaceToCore
:
[object Object]
lastAngularVelocity
:
[object Object]
lastAngularVelocityBrakeCouple
:
[object Object]
lastSlip
:
[object Object]
lastSlipError
:
[object Object]
lastTorqueMode
:
[object Object]
minABSCoef
:
[object Object]
name
:
[object Object]
node1
:
[object Object]
node2
:
[object Object]
obj
{8}
getPeakPeriod(*)
[2]
0
:
if peakForce > 0 and wd.obj:getPeakPeriod() * vehicleSpeed > 0.0 then
1
:
-- if wd.name == "FL" then print (string.format("peakForce=%6.0f / wd.obj:getPeakPeriod()=%0.2f / vehicleSpeed=%0.3f", peakForce, wd.obj:getPeakPeriod(), vehicleSpeed));
getSlipEnergy(*)
:
[object Object]
getSlipVelEnergy(*)
:
[object Object]
getSlipVelEnergyDownPeakForce(*)
[1]
0
:
wd.lastSlip, wd.slipEnergy, wd.downForceRaw, wd.peakForce = wd.obj:getSlipVelEnergyDownPeakForce()
isRotatingBrakeCouple(*)
[1]
0
:
local isRotatingBrakeCouple = wd.obj:isRotatingBrakeCouple() --0,1 coef based on instability detection of the wheel AV inside the core
setBrakeSpring(*)
[1]
0
:
wobj:setBrakeSpring(max(wd.brakeTorque or 0, wd.parkingTorque or 0, 1) * (wd.brakeSpring or 10))
setEngineAxisCoupleNodes(*)
[1]
0
:
wheel.obj:setEngineAxisCoupleNodes(reactionNodes[1], reactionNodes[2], reactionNodes[3])
setTorqueAndBrakeTorque(*)
:
[object Object]
oppositeSide
:
[object Object]
ownSide
:
[object Object]
padGlazingFactor
:
[object Object]
padMaterial
:
[object Object]
parkingTorque
:
[object Object]
peakForce
:
[object Object]
pressureGroup
:
[object Object]
propulsionTorque
:
[object Object]
radius
:
[object Object]
rayCount
:
[object Object]
rimAirTemperature
:
[object Object]
rimEnergyCoef
:
[object Object]
rimTemperature
:
[object Object]
rotatorType
:
[object Object]
rotorMaterial
:
[object Object]
slipEnergy
:
[object Object]
slipErrorIntegral
:
[object Object]
slipRatioTarget
:
[object Object]
smokeParticleTick
:
[object Object]
softnessCoef
:
[object Object]
squealCoefGlazing
:
[object Object]
squealCoefLowSpeed
:
[object Object]
squealCoefNatural
:
[object Object]
steamParticleTick
:
[object Object]
thermalEfficiencyConfig
{5}
a
:
[object Object]
b1
:
[object Object]
b2
:
[object Object]
w1x1Coef
:
[object Object]
w2x1Coef
:
[object Object]
tireAirEnergyCoef
:
[object Object]
tireAirTemperature
:
[object Object]
tireVolume
:
[object Object]
tireWidth
:
[object Object]
torsionReactor
{31}
children
:
[object Object]
connectedChildrenCount
:
[object Object]
cumulativeGearRatio
:
[object Object]
cumulativeInertia
:
[object Object]
deviceCategories
{1}
shaft
:
[object Object]
friction
:
[object Object]
gearRatio
:
[object Object]
inputAV
:
[object Object]
inputIndex
:
[object Object]
inputName
:
[object Object]
invCumulativeInertia
:
[object Object]
isBroken
:
[object Object]
isPhysicallyDisconnected
:
[object Object]
isPropulsed
:
[object Object]
maxCumulativeGearRatio
:
[object Object]
name
[3]
0
:
if not torsionReactorIndexes[rotator.torsionReactor.name] then
1
:
torsionReactorIndexes[rotator.torsionReactor.name] = torsionReactorCount
2
:
local trIdx = torsionReactorIndexes[rotator.torsionReactor.name]
outputAV1
:
[object Object]
outputPorts
:
[object Object]
outputTorque1
:
[object Object]
parentOutputAVName
:
[object Object]
parentOutputTorqueName
:
[object Object]
torqueReactionNodes
:
[object Object]
type
[2]
0
:
while torsionReactor.parent and torsionReactor.type ~= "torsionReactor" do
1
:
if torsionReactor and torsionReactor.type == "torsionReactor" and torsionReactor.torqueReactionNodes then
uiName
:
[object Object]
visualShaftAVName
:
[object Object]
calculateInertia(device)
:
[object Object]
onBreak()
:
[object Object]
reset(device, jbeamData)
:
[object Object]
torqueUpdate(device)
:
[object Object]
validate(device)
:
[object Object]
velocityUpdate(device, dt)
:
[object Object]
torsionReactorIdx
:
[object Object]
treadCoef
:
[object Object]
treadCoreEnergyCoef
:
[object Object]
treadCoreTemperature
:
[object Object]
treadNodes
:
[object Object]
treadSurfaceEnergyCoef
:
[object Object]
treadSurfaceTemperature
:
[object Object]
wheelDir
:
[object Object]
wheelID
:
[object Object]
wheelSpeed
:
[object Object]
wheelSpeedCoreCooling
:
[object Object]
updateBrake(wd, brake, invAirspeed, airspeed, airspeedCutOff, dt)
:
[object Object]
RR
{109}
absFrequency
:
[object Object]
absTime
:
[object Object]
absTimer
:
[object Object]
airSpeedCoreCooling
:
[object Object]
angularVelocity
:
[object Object]
angularVelocityBrakeCouple
:
[object Object]
brakeCoolingArea
:
[object Object]
brakeCoreEnergyCoef
:
[object Object]
brakeCoreTemperature
:
[object Object]
brakeDiameter
:
[object Object]
brakeInputSplit
:
[object Object]
brakeMass
:
[object Object]
brakeMeltingPoint
:
[object Object]
brakePressureDelay
{1}
state
:
[object Object]
brakeSpecHeat
:
[object Object]
brakeSplitCoef
:
[object Object]
brakeSquealLoop
{5}
lastColor
:
[object Object]
lastPitch
:
[object Object]
lastTexture
:
[object Object]
lastVol
:
[object Object]
obj
:
[object Object]
brakeSquealVolumeSmoother
{2}
autoCenterRate
:
[object Object]
state
:
[object Object]
brakeSurfaceEnergyCoef
:
[object Object]
brakeSurfaceTemperature
:
[object Object]
brakeThermalEfficiency
:
[object Object]
brakeTorque
:
[object Object]
brakeType
:
[object Object]
brakeTypeCoreCoolingCoef
:
[object Object]
brakeTypeSurfaceCoolingCoef
:
[object Object]
brakeVentingCoef
:
[object Object]
brakingTorque
:
[object Object]
cid
:
[object Object]
contactDepth
:
[object Object]
contactMaterialID1
:
[object Object]
contactMaterialID2
:
[object Object]
coreData
:
[object Object]
deflatedTireAngle
:
[object Object]
desiredBrakingTorque
:
[object Object]
downForce
:
[object Object]
downForceRaw
:
[object Object]
downForceSmoother
{1}
state
:
[object Object]
dynamicRadius
:
[object Object]
dynamicRadiusSmoother
{1}
state
:
[object Object]
enableBrakeThermals
:
[object Object]
flatTireSound
:
[object Object]
frictionTorque
:
[object Object]
hasABS
:
[object Object]
hasTire
:
[object Object]
hubRadius
:
[object Object]
inertia
:
[object Object]
initialBrakeTorque
:
[object Object]
initialParkingTorque
:
[object Object]
invInitialBrakeTorque
:
[object Object]
invRelativeBrakingTorqueCoef
:
[object Object]
isBrakeMolten
:
[object Object]
isBroken
:
[object Object]
isPropulsed
:
[object Object]
isSpeedo
:
[object Object]
isTireDeflated
:
[object Object]
kRadiationToAir
:
[object Object]
kSurfaceToCore
:
[object Object]
lastAngularVelocity
:
[object Object]
lastAngularVelocityBrakeCouple
:
[object Object]
lastSlip
:
[object Object]
lastSlipError
:
[object Object]
lastTorqueMode
:
[object Object]
minABSCoef
:
[object Object]
name
:
[object Object]
node1
:
[object Object]
node2
:
[object Object]
obj
{8}
getPeakPeriod(*)
[2]
0
:
if peakForce > 0 and wd.obj:getPeakPeriod() * vehicleSpeed > 0.0 then
1
:
-- if wd.name == "FL" then print (string.format("peakForce=%6.0f / wd.obj:getPeakPeriod()=%0.2f / vehicleSpeed=%0.3f", peakForce, wd.obj:getPeakPeriod(), vehicleSpeed));
getSlipEnergy(*)
:
[object Object]
getSlipVelEnergy(*)
:
[object Object]
getSlipVelEnergyDownPeakForce(*)
[1]
0
:
wd.lastSlip, wd.slipEnergy, wd.downForceRaw, wd.peakForce = wd.obj:getSlipVelEnergyDownPeakForce()
isRotatingBrakeCouple(*)
[1]
0
:
local isRotatingBrakeCouple = wd.obj:isRotatingBrakeCouple() --0,1 coef based on instability detection of the wheel AV inside the core
setBrakeSpring(*)
[1]
0
:
wobj:setBrakeSpring(max(wd.brakeTorque or 0, wd.parkingTorque or 0, 1) * (wd.brakeSpring or 10))
setEngineAxisCoupleNodes(*)
[1]
0
:
wheel.obj:setEngineAxisCoupleNodes(reactionNodes[1], reactionNodes[2], reactionNodes[3])
setTorqueAndBrakeTorque(*)
:
[object Object]
oppositeSide
:
[object Object]
ownSide
:
[object Object]
padGlazingFactor
:
[object Object]
padMaterial
:
[object Object]
parkingTorque
:
[object Object]
peakForce
:
[object Object]
pressureGroup
:
[object Object]
propulsionTorque
:
[object Object]
radius
:
[object Object]
rayCount
:
[object Object]
rimAirTemperature
:
[object Object]
rimEnergyCoef
:
[object Object]
rimTemperature
:
[object Object]
rotatorType
:
[object Object]
rotorMaterial
:
[object Object]
slipEnergy
:
[object Object]
slipErrorIntegral
:
[object Object]
slipRatioTarget
:
[object Object]
smokeParticleTick
:
[object Object]
softnessCoef
:
[object Object]
squealCoefGlazing
:
[object Object]
squealCoefLowSpeed
:
[object Object]
squealCoefNatural
:
[object Object]
steamParticleTick
:
[object Object]
thermalEfficiencyConfig
{5}
a
:
[object Object]
b1
:
[object Object]
b2
:
[object Object]
w1x1Coef
:
[object Object]
w2x1Coef
:
[object Object]
tireAirEnergyCoef
:
[object Object]
tireAirTemperature
:
[object Object]
tireVolume
:
[object Object]
tireWidth
:
[object Object]
torsionReactor
{31}
children
:
[object Object]
connectedChildrenCount
:
[object Object]
cumulativeGearRatio
:
[object Object]
cumulativeInertia
:
[object Object]
deviceCategories
{1}
shaft
:
[object Object]
friction
:
[object Object]
gearRatio
:
[object Object]
inputAV
:
[object Object]
inputIndex
:
[object Object]
inputName
:
[object Object]
invCumulativeInertia
:
[object Object]
isBroken
:
[object Object]
isPhysicallyDisconnected
:
[object Object]
isPropulsed
:
[object Object]
maxCumulativeGearRatio
:
[object Object]
name
[3]
0
:
if not torsionReactorIndexes[rotator.torsionReactor.name] then
1
:
torsionReactorIndexes[rotator.torsionReactor.name] = torsionReactorCount
2
:
local trIdx = torsionReactorIndexes[rotator.torsionReactor.name]
outputAV1
:
[object Object]
outputPorts
:
[object Object]
outputTorque1
:
[object Object]
parentOutputAVName
:
[object Object]
parentOutputTorqueName
:
[object Object]
torqueReactionNodes
:
[object Object]
type
[2]
0
:
while torsionReactor.parent and torsionReactor.type ~= "torsionReactor" do
1
:
if torsionReactor and torsionReactor.type == "torsionReactor" and torsionReactor.torqueReactionNodes then
uiName
:
[object Object]
visualShaftAVName
:
[object Object]
calculateInertia(device)
:
[object Object]
onBreak()
:
[object Object]
reset(device, jbeamData)
:
[object Object]
torqueUpdate(device)
:
[object Object]
validate(device)
:
[object Object]
velocityUpdate(device, dt)
:
[object Object]
torsionReactorIdx
:
[object Object]
treadCoef
:
[object Object]
treadCoreEnergyCoef
:
[object Object]
treadCoreTemperature
:
[object Object]
treadNodes
:
[object Object]
treadSurfaceEnergyCoef
:
[object Object]
treadSurfaceTemperature
:
[object Object]
wheelDir
:
[object Object]
wheelID
:
[object Object]
wheelSpeed
:
[object Object]
wheelSpeedCoreCooling
:
[object Object]
updateBrake(wd, brake, invAirspeed, airspeed, airspeedCutOff, dt)
:
[object Object]
beamBroke(id)
[1]
0
:
powertrain.beamBroke(id)
breakDevice(device)
:
[object Object]
calculateTreeInertia()
[3]
0
:
powertrain.calculateTreeInertia()
1
:
powertrain.calculateTreeInertia()
2
:
powertrain.calculateTreeInertia()
dumpsDeviceData(device)
[3]
0
:
log("E", "automaticGearbox.validate", powertrain.dumpsDeviceData(device.parent))
1
:
log("E", "combustionEngine.validate", powertrain.dumpsDeviceData(device.children))
2
:
log("E", "dctGearbox.validate", powertrain.dumpsDeviceData(device.parent))
getChildWheels(parentDevice, outputID)
[3]
0
:
relevantWheels[-1].wheels = powertrain.getChildWheels(relevantDifferential, 1)
1
:
relevantWheels[1].wheels = powertrain.getChildWheels(relevantDifferential, 2)
2
:
relevantWheels[-1].wheels = powertrain.getChildWheels(relevantDifferential, 1)
getDevice(name)
[3]
0
:
shaft = powertrain.getDevice(jbeamData.shaftName)
1
:
rangeBox = powertrain.getDevice(jbeamData.rangeBoxName)
2
:
relevantDifferential = powertrain.getDevice(diffName)
getDevices()
[3]
0
:
for _, device in pairs(powertrain.getDevices()) do
1
:
for _, device in pairs(powertrain.getDevices()) do
2
:
if next(powertrain.getDevices()) then
getDevicesByCategory(category)
[3]
0
:
local engines = powertrain.getDevicesByCategory("engine")
1
:
local motors = powertrain.getDevicesByCategory("engine")
2
:
local transmissions = powertrain.getDevicesByCategory("gearbox")
getDevicesByType(deviceType)
[3]
0
:
for k, v in pairs(powertrain.getDevicesByType('combustionEngine')) do
1
:
for k, v in pairs(powertrain.getDevicesByType('combustionEngine')) do
2
:
local engines = powertrain.getDevicesByType("combustionEngine")
getEngineSoundID()
[3]
0
:
device.engineSoundID = powertrain.getEngineSoundID()
1
:
device.engineSoundIDExhaust = powertrain.getEngineSoundID()
2
:
device.engineSoundID = powertrain.getEngineSoundID()
getOrderedDevices()
[2]
0
:
for k, v in ipairs(powertrain.getOrderedDevices()) do
1
:
local orderedDevices = powertrain.getOrderedDevices()
getPartCondition(partTypeData)
[1]
0
:
local powertrainCondition, canProvidePowertrainCondition = powertrain.getPartCondition(partData)
getPropulsionDeviceForWheel(wheelName)
[1]
0
:
local wheelPropulsionDevice = powertrain.getPropulsionDeviceForWheel(wd.name)
init()
[1]
0
:
powertrain.init()
initSounds()
[1]
0
:
powertrain.initSounds()
isPhysicsStepUsed()
:
[object Object]
reset()
[1]
0
:
powertrain.reset()
resetSounds()
[1]
0
:
powertrain.resetSounds()
sendDeviceTree()
:
[object Object]
serializeDevicesInfo()
:
[object Object]
setDeviceMode(name, mode)
[2]
0
:
powertrain.setDeviceMode(rangeBox.name, mode)
1
:
powertrain.setDeviceMode(shaft.name, mode)
setPartCondition(partTypeData, odometer, integrity, visual)
[1]
0
:
powertrain.setPartCondition(partTypes, odometer, integrity, visual)
setVehiclePath(path)
[1]
0
:
powertrain.setVehiclePath(path)
toggleDefaultDiffs()
:
[object Object]
toggleDeviceMode(name)
[2]
0
:
powertrain.toggleDeviceMode(rangeBox.name)
1
:
powertrain.toggleDeviceMode(shaft.name)
update(dt)
[1]
0
:
powertrain.update(dtSim)
updateGFX(dt)
[1]
0
:
powertrain.updateGFX(dtSim)
props
{5}
disablePropsInDeformGroup(deformGroup)
[1]
0
:
props.disablePropsInDeformGroup(g.deformGroup)
hidePropsInBreakGroup(breakGroup)
[2]
0
:
props.hidePropsInBreakGroup(g)
1
:
props.hidePropsInBreakGroup(g)
init()
[1]
0
:
props.init()
reset()
[1]
0
:
props.reset()
update()
[1]
0
:
props.update()
recovery
{15}
recoveryPoints
{2}
head
:
[object Object]
tail
:
[object Object]
safePoints
{1}
home
{3}
dirFront
{5}
cross(*)
:
[object Object]
dot(*)
:
[object Object]
length(*)
:
[object Object]
normalize(*)
:
[object Object]
set(*)
:
[object Object]
dirUp
{5}
cross(*)
[1]
0
:
local dirLeft = dirUp:cross(dirFront)
dot(*)
:
[object Object]
length(*)
:
[object Object]
normalize(*)
:
[object Object]
set(*)
:
[object Object]
pos
:
[object Object]
clear()
:
[object Object]
getFreeCamActiveFlag()
[1]
0
:
obj:queueGameEngineLua('queueObjectLua('..tostring(obj:getID())..', "if recovery.getFreeCamActiveFlag() ~= nil then recovery.setFreeCamActiveFlag(" .. tostring(commands.isFreeCamera()) .. ") ") commands.setFreeCamera()')
init(path)
[1]
0
:
recovery.init()
loadHome()
[1]
0
:
recovery.loadHome()
loadPoint(pointName)
:
[object Object]
onDeserialized(v)
:
[object Object]
recoverInPlace()
:
[object Object]
saveHome(point)
:
[object Object]
savePoint(pointName)
:
[object Object]
setFreeCamActiveFlag(active)
[1]
0
:
obj:queueGameEngineLua('queueObjectLua('..tostring(obj:getID())..', "if recovery.getFreeCamActiveFlag() ~= nil then recovery.setFreeCamActiveFlag(" .. tostring(commands.isFreeCamera()) .. ") ") commands.setFreeCamera()')
startRecovering(useAltMode)
:
[object Object]
stopRecovering()
:
[object Object]
updateGFX(dt)
[1]
0
:
recovery.updateGFX(dtSim)
scenario
{1}
freeze(mode)
[1]
0
:
log("W", "controller", "scenario.freeze(mode) is deprecated. Please switch to controller.setFreeze(mode)")
sensors
{10}
ffiSensors
[3]
0
:
accelerationSensorSpeed = accelerationSensorSpeed - sensors.ffiSensors.sensorY * dt
1
:
local refNodeAcc = lateralAccSmoother:getUncapped(abs(sensors.ffiSensors.sensorX), dt)
2
:
local ffisensors = sensors.ffiSensors
gx
[3]
0
:
local targetSpeed = max(0, aiSpeed - sqrt(max(0, square(staticFrictionCoef * g) - square(sensors.gx2))) * dt)
1
:
local gforce = sensors.gx2 / 9.81
2
:
lsensors.gx = sensors.gx
gx2
[3]
0
:
local targetSpeed = max(0, aiSpeed - sqrt(max(0, square(staticFrictionCoef * g) - square(sensors.gx2))) * dt)
1
:
local gforce = sensors.gx2 / 9.81
2
:
lsensors.gx2 = sensors.gx2
gy
[3]
0
:
if abs(sensors.gy2) > 3 then
1
:
local acc = sensors.gy2 / obj:getGravity()
2
:
lsensors.gy = sensors.gy
gy2
[3]
0
:
if abs(sensors.gy2) > 3 then
1
:
local acc = sensors.gy2 / obj:getGravity()
2
:
lsensors.gy2 = sensors.gy2
gz
[3]
0
:
if sensors.gz <= 0 then
1
:
local oilStarvingSevernessZ = sensors.gz2
2
:
lsensors.gz = sensors.gz
gz2
[2]
0
:
local oilStarvingSevernessZ = sensors.gz2
1
:
lsensors.gz2 = sensors.gz2
init()
[1]
0
:
sensors.init()
reset()
[2]
0
:
sensors.reset()
1
:
sensors.reset()
updateGFX(dt)
[1]
0
:
sensors.updateGFX(dtSim) -- must be before input and ai
settings
{2}
getValue(key, defaultValue)
[3]
0
:
startPreHeated = settings.getValue("startThermalsPreHeated")
1
:
-- local escBehavior = settings.getValue("escBehavior") or "realistic"
2
:
local limitEnabled = settings.getValue("inputFilter"..tostring(v).."_limitEnabled" , false)
refresh()
[1]
0
:
settings.refresh()
socket
{12}
dns
{5}
getaddrinfo(*)
[1]
0
:
local addrinfo, err = socket.dns.getaddrinfo(host);
gethostname(*)
:
[object Object]
getnameinfo(*)
:
[object Object]
tohostname(*)
:
[object Object]
toip(*)
:
[object Object]
connect(*)
[2]
0
:
return socket.connect(address, port, laddress, lport, "inet")
1
:
return socket.connect(address, port, laddress, lport, "inet6")
gettime(*)
:
[object Object]
newtry(*)
:
[object Object]
protect(*)
:
[object Object]
select(*)
[3]
0
:
_readable_task._evs, _writable_task._evs, err = socket.select(_reading, _writing, timeout)
1
:
local readyt = socket.select(readt, nil, 0)
2
:
local read, write, _ = socket.select(clients_read, clients_write, 0) -- _ = 'timeout' or nil, does not matter for our non-blocking usecase
skip(*)
[3]
0
:
local a, b, c, d, p1, p2 = socket.skip(2, string.find(reply, pattern))
1
:
local sent = socket.skip(1, self.data:getstats())
2
:
t.type = socket.skip(2, string.find(t.params, pat))
sleep(*)
[2]
0
:
socket.sleep(sleepTime)
1
:
socket.sleep(sleepTime)
tcp(*)
[3]
0
:
self.sock = socket.tcp()
1
:
sock = socket.tcp()
2
:
self.sock = socket.tcp()
tcp6(*)
[1]
0
:
sock, err = socket.tcp6()
udp(*)
[3]
0
:
local udpSocket = socket.udp()
1
:
udpSocket = socket.udp()
2
:
udpSocket = socket.udp()
udp6(*)
:
[object Object]
sounds
{22}
engineNode
[3]
0
:
device.gearWhineOutputLoop = sounds.createSoundObj(gearWhineOutputSample, "AudioDefaultLoop3D", "GearWhineOut", device.transmissionNodeID or sounds.engineNode)
1
:
device.gearWhineInputLoop = sounds.createSoundObj(gearWhineInputSample, "AudioDefaultLoop3D", "GearWhineIn", device.transmissionNodeID or sounds.engineNode)
2
:
device.gearWhineOutputLoop = sounds.createSoundObj(gearWhineOutputSample, "AudioDefaultLoop3D", "GearWhineOut", device.transmissionNodeID or sounds.engineNode)
refNode
:
[object Object]
uiDebugging
:
[object Object]
usesOldCustomSounds
[3]
0
:
if not sounds.usesOldCustomSounds then
1
:
if not sounds.usesOldCustomSounds then
2
:
if not sounds.usesOldCustomSounds then
FMODHzToHz(fmodHzValue)
:
[object Object]
bodyCollision(p)
[2]
0
:
sounds.bodyCollision(p)
1
:
sounds.bodyCollision(p)
createSFXSource(filename, description, SFXProfileName, nodeID)
:
[object Object]
createSoundObj(filename, description, SFXProfileName, nodeID)
[3]
0
:
device.gearWhineOutputLoop = sounds.createSoundObj(gearWhineOutputSample, "AudioDefaultLoop3D", "GearWhineOut", device.transmissionNodeID or sounds.engineNode)
1
:
device.gearWhineInputLoop = sounds.createSoundObj(gearWhineInputSample, "AudioDefaultLoop3D", "GearWhineIn", device.transmissionNodeID or sounds.engineNode)
2
:
device.gearWhineOutputLoop = sounds.createSoundObj(gearWhineOutputSample, "AudioDefaultLoop3D", "GearWhineOut", device.transmissionNodeID or sounds.engineNode)
createSoundscapeSound(name)
[3]
0
:
hornSound = hornSound or sounds.createSoundscapeSound("horn")
1
:
sirenSound = sirenSound or sounds.createSoundscapeSound("siren")
2
:
indStartSnd = indStartSnd or sounds.createSoundscapeSound("indicatorStart")
disableOldEngineSounds()
[3]
0
:
sounds.disableOldEngineSounds()
1
:
sounds.disableOldEngineSounds()
2
:
sounds.disableOldEngineSounds()
getBeamSounds()
:
[object Object]
getEngineSoundData()
:
[object Object]
hzToFMODHz(hzValue)
[3]
0
:
local fundamentalFreq = sounds.hzToFMODHz(rpm * device.soundConfiguration.engine.params.fundamentalFrequencyRPMCoef)
1
:
local fundamentalFreqExhaust = sounds.hzToFMODHz(rpm * device.soundConfiguration.exhaust.params.fundamentalFrequencyRPMCoef)
2
:
local eq_a_freq = sounds.hzToFMODHz(soundConfig.lowShelfFreq or soundConfig.lowCutFreq or 20)
init()
[1]
0
:
sounds.init()
onDeserialized()
:
[object Object]
playSound(sound, volume)
:
[object Object]
playSoundOnceAtNode(soundName, nodeID, volume, pitch, color, texture)
[2]
0
:
--sounds.playSoundOnceAtNode("event:>fabian_test", 0, 1)
1
:
-- sounds.playSoundOnceAtNode("event:>Vehicle>Interior>Rattles>car>multi_test", 0, volume)
playSoundOnceFollowNode(soundName, nodeID, volume, pitch, color, texture)
[3]
0
:
sounds.playSoundOnceFollowNode("event:>Vehicle>Tire_Burst", wheel.node1, 1)
1
:
sounds.playSoundOnceFollowNode("event:>Vehicle>Failures>engine_explode", device.engineBlockNodes[1], 1)
2
:
sounds.playSoundOnceFollowNode("event:>Vehicle>Failures>engine_explode", device.engineBlockNodes[1], 1)
playSoundSkipAI(sound, volume)
[3]
0
:
sounds.playSoundSkipAI(indLoopSnd1)
1
:
sounds.playSoundSkipAI(indLoopSnd2)
2
:
sounds.playSoundSkipAI(indStopSnd)
reset()
[1]
0
:
sounds.reset()
setUIDebug(enabled, data)
:
[object Object]
updateGFX(dt)
[1]
0
:
sounds.updateGFX(dtSim)
streams
{6}
drawGraph(k, val)
[3]
0
:
-- streams.drawGraph('w'..bi, {value = volume, max = 1})
1
:
-- streams.drawGraph(wd.name.." (asphalt_rigidSkidSlip", {value = rigidSkidSlip + 0.5, max = 1})
2
:
-- streams.drawGraph(wd.name.." "..'SkidVolume', {value = rigidSkidVolume, max = 1})
hasActiveStreams()
[1]
0
:
if streams.hasActiveStreams() and obj:getUpdateUIflag() then
reset()
:
[object Object]
setRequiredStreams(state)
:
[object Object]
update()
[1]
0
:
streams.update()
willSend(name)
[3]
0
:
if streams.willSend("escInfo") and controlParameters.uiDisplayData.simplePowertrainApp.doUpdate then
1
:
if streams.willSend("engineThermalData") then
2
:
if streams.willSend("engineThermalData") then
string
{21}
byte(*)
[3]
0
:
local cc = string.byte(cmd)
1
:
if string.byte(k, 13) == 58 then --backwards compat for using : instead of _ for the delim
2
:
b1 = asciitbl[string.byte(string.sub(a,1,1))]
char(*)
[3]
0
:
local ch = string.char(i)
1
:
jsonError(string.format("Expected dictionary separator ':' or '=' instead of: '%s'", string.char(delim)), i)
2
:
serTmp[seridx] = vlen < 10 and 'A' or (vlen < 100 and 'B' or string.char(65 + math.floor(math.log10(vlen))))
dump(*)
[1]
0
:
local luac = string.dump(loadstring "a = 1")
endswith(String, End)
:
[object Object]
find(*)
[3]
0
:
local i = string.find(k, '\0')
1
:
if type(g) == "string" and (string.find(g, "hinge") ~= nil or string.find(g, "latch") ~= nil) then
2
:
local delim_from, delim_to = string.find(self, delimiter, from)
format(*)
[3]
0
:
--print("%F:"..' '..string.format("%.2f",aeroData.percentFront)..' '.."%R:"..' '..string.format("%.2f",aeroData.percentRear)..' '.."Net Force X:"..' '..string.format("%.2f",aeroData.afX)..' '.."Y:"..''..string.format("%.2f",aeroData.afY)..' '.."Z:"..''..string.format("%.2f",aeroData.afZ))
1
:
guihooks.message(string.format("Trim (%s): %d%%", k, v * 100), 1, "vehicle.trimvalue" .. k)
2
:
guihooks.message(string.format("Flaps: %d%%", flap * 100), 1, "vehicle.flaps")
gmatch(*)
[3]
0
:
for uri in string.gmatch(line, "GET /([^ ]*) HTTP/[0-9].[0-9]") do
1
:
for uri in string.gmatch(line, "GET (/[^ ]*) HTTP/[0-9].[0-9]") do
2
:
for l in string_gmatch(info.source, "([^\n]+)\n-") do
gsub(*)
[3]
0
:
local _,lno = string.gsub( s, "\n", "\n" )
1
:
local name = "[\"" .. string.gsub( s, "\n", "\\n" ) .. "\"]"
2
:
extPath = string.gsub(extPath, "/(.*)", "%1")
len()
[3]
0
:
["content-length"] = string.len(reqbody)
1
:
if string.len(rootName) > 0 then
2
:
local size = string.format("%X\r\n", string.len(chunk))
lower(*)
[3]
0
:
icon = "radial_" .. string.lower(v.name:gsub(" ", "_")),
1
:
resolvedNormalizedNameToModule[string.lower(mname)] = m
2
:
resolvedNormalizedNameToModule[string.lower(mname)] = m
match(*)
[3]
0
:
if string.match( k, "^%u%w*$" ) then
1
:
res.file = string.match(path, "^.+/(.+)$")
2
:
ctype = string.match(ctype, "class<([^>]*)>")
rep(*)
[3]
0
:
local marker = string.rep( " ", p-sol ) .. "^"
1
:
sub_print_r(val,indent..string.rep(" ",string.len(pos)+8))
2
:
print(indent..string.rep(" ",string.len(pos)+6).."}")
reverse(*)
:
[object Object]
rstripchars(String, chrs)
:
[object Object]
sentenceCase(str)
:
[object Object]
split(String, delimregex)
:
[object Object]
startswith(String, Start)
:
[object Object]
stripchars(String, chrs)
:
[object Object]
stripcharsFrontBack(str, chrs)
:
[object Object]
sub(*)
[3]
0
:
local n1id = string.sub(k, 1, i-1)
1
:
targetLink = string.sub(k, i+1, #k)
2
:
return string.sub(tostring(socket),1,3) ~= "udp"
upper(*)
[3]
0
:
text = string.upper(text)
1
:
cmd = string.upper(cmd)
2
:
return string.upper(result:sub(1, 1)) .. result:sub(2)
table
{13}
clear(*)
[3]
0
:
table.clear(trafficTable)
1
:
table.clear(planets)
2
:
table.clear(planetTimers)
concat(*)
[3]
0
:
return jsonDecode(table.concat(respbody), 'json request response')
1
:
return table.concat(stringTable, " ")
2
:
local commonFilterArgumentsStr = table.concat(commonFilterArguments, ',')
deepcopy(*)
:
[object Object]
foreach()
:
[object Object]
foreachi()
:
[object Object]
getn()
:
[object Object]
insert(*)
[3]
0
:
table.insert(entries, wdEntry)
1
:
table.insert(entries, rmEntry)
2
:
table.insert(dampBeams, b.cid)
maxn(*)
[3]
0
:
local odometer, integrityValue, integrityState, visualValue, visualState = unpack(partCondition, 1, table.maxn(partCondition))
1
:
local odometer, integrityValue, integrityState, visualValue, visualState, omitSpawn = unpack(partCondition, 1, table.maxn(partCondition))
2
:
local narg = table.maxn(arg)
move()
:
[object Object]
new(*)
[3]
0
:
local dict = table.new(0, sourceCount-(srcStart-1))
1
:
local res = table.new(destCount, 0)
2
:
local beamIndex = table.new(0, #vehicle.beams)
remove()
[3]
0
:
table.remove(trafficTable, j)
1
:
table.remove(planets)
2
:
table.remove(planetTimers)
shallowcopy(*)
:
[object Object]
sort(*)
[3]
0
:
table.sort(
1
:
table.sort(
2
:
table.sort(
thrusters
{7}
applyImpulse(n1, n2, force, dt)
:
[object Object]
applyImpulseBody(force, dt)
:
[object Object]
init()
[1]
0
:
thrusters.init()
isPhysicsStepUsed()
:
[object Object]
reset()
[1]
0
:
thrusters.reset()
update()
[1]
0
:
thrusters.update()
updateGFX()
[1]
0
:
thrusters.updateGFX() -- should be after extensions.hook
v
{4}
config
{6}
licenseName
[1]
0
:
extensions.core_vehicles.setPlateText((config and config.licenseName) or false, objID, licenseplatePath, licensePlateUsedFormats)
model
:
[object Object]
paints
:
[object Object]
partConfigFilename
[2]
0
:
if v.config.partConfigFilename then
1
:
local _, configName = path.splitWithoutExt(v.config.partConfigFilename)
parts
{86}
brakepad_F
:
[object Object]
brakepad_R
:
[object Object]
etk800_DSE
:
[object Object]
etk800_DSE_ABS
:
[object Object]
etk800_DSE_ESC
:
[object Object]
etk800_DSE_TC
:
[object Object]
etk800_DSE_drivemodes
:
[object Object]
etk800_DSE_drivemodes_default
:
[object Object]
etk800_DSE_drivemodes_drift
:
[object Object]
etk800_DSE_drivemodes_ttSport
:
[object Object]
etk800_body
:
[object Object]
etk800_brake_F
:
[object Object]
etk800_brake_R
:
[object Object]
etk800_bumper_F
:
[object Object]
etk800_bumper_R
:
[object Object]
etk800_bumperbar_F
:
[object Object]
etk800_differential_F
:
[object Object]
etk800_differential_R
:
[object Object]
etk800_diffuser_R
:
[object Object]
etk800_door_FL
:
[object Object]
etk800_door_FR
:
[object Object]
etk800_door_RL_wagon
:
[object Object]
etk800_door_RR_wagon
:
[object Object]
etk800_doorglass_FL
:
[object Object]
etk800_doorglass_FR
:
[object Object]
etk800_doorglass_RL_wagon
:
[object Object]
etk800_doorglass_RR_wagon
:
[object Object]
etk800_driveshaft_F
:
[object Object]
etk800_driveshaft_R
:
[object Object]
etk800_fender_L
:
[object Object]
etk800_fender_R
:
[object Object]
etk800_fueltank
:
[object Object]
etk800_glass_wagon
:
[object Object]
etk800_headlight_L
:
[object Object]
etk800_headlight_R
:
[object Object]
etk800_hood
:
[object Object]
etk800_lettering_tailgate
:
[object Object]
etk800_licenseplate_F_alt
:
[object Object]
etk800_licenseplate_R
:
[object Object]
etk800_lightbar
:
[object Object]
etk800_mirror_L
:
[object Object]
etk800_mirror_R
:
[object Object]
etk800_power_steering
:
[object Object]
etk800_radiator
:
[object Object]
etk800_roof_wagon
:
[object Object]
etk800_seat_FL
:
[object Object]
etk800_seat_FR
:
[object Object]
etk800_seats_R
:
[object Object]
etk800_shifter
:
[object Object]
etk800_shock_R
:
[object Object]
etk800_spring_R
:
[object Object]
etk800_steer
:
[object Object]
etk800_steering
:
[object Object]
etk800_strut_F
:
[object Object]
etk800_strutbrace_F
:
[object Object]
etk800_suspension_F
:
[object Object]
etk800_suspension_R
:
[object Object]
etk800_swaybar_F
:
[object Object]
etk800_swaybar_R
:
[object Object]
etk800_tailgate
:
[object Object]
etk800_tailgateglass
:
[object Object]
etk800_taillight_L
:
[object Object]
etk800_taillight_R
:
[object Object]
etk800_towhitch
:
[object Object]
etk800_wheeldata_F
:
[object Object]
etk800_wheeldata_R
:
[object Object]
etk_converter
:
[object Object]
etk_engine
:
[object Object]
etk_engine_i6_ecu
:
[object Object]
etk_engine_i6_internals
:
[object Object]
etk_exhaust_i6_petrol
:
[object Object]
etk_intake_i6
:
[object Object]
etk_transfer_case
:
[object Object]
etk_transmission
:
[object Object]
gps
:
[object Object]
licenseplate_design_2_1
:
[object Object]
linelock
:
[object Object]
n2o_system
:
[object Object]
paint_design
:
[object Object]
skin_gauges
:
[object Object]
skin_interior
:
[object Object]
soundscape_horn
:
[object Object]
tire_F_18x9
:
[object Object]
tire_R_18x9
:
[object Object]
wheel_F_5
:
[object Object]
wheel_R_5
:
[object Object]
vars
{12}
$camber_FL
:
[object Object]
$camber_FR
:
[object Object]
$camber_RL
:
[object Object]
$camber_RR
:
[object Object]
$tirepressure_F
:
[object Object]
$tirepressure_R
:
[object Object]
$toe_FL
:
[object Object]
$toe_FR
:
[object Object]
$toe_RL
:
[object Object]
$toe_RR
:
[object Object]
$trackwidth_F
:
[object Object]
$trackwidth_R
:
[object Object]
data
{42}
activeParts
{95}
brakepad_F_sport
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
brakepad_R_sport
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
etk800
{8}
controller
:
[object Object]
glowMap
{26}
abs
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
checkengine
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
esc
{3}
off
:
[object Object]
on
[3]
0
:
if v.data.escConfig then
1
:
v.data.esc = v.data.escConfig
2
:
local escConfigurations = {}
simpleFunction
:
[object Object]
etk800_chmsl
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
brakelights
:
[object Object]
etk800_foglight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
fog
:
[object Object]
etk800_gauges
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
etk800_headlight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{2}
highbeam
:
[object Object]
lowbeam
:
[object Object]
etk800_parkinglight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
parking
:
[object Object]
etk800_reverselight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
reverse
:
[object Object]
etk800_runninglight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
running
:
[object Object]
etk800_signal_L
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
signal_L
:
[object Object]
etk800_signal_R
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
signal_R
:
[object Object]
etk800_taillight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
brakelights
:
[object Object]
etk800_taillight_L
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{2}
lowhighbeam
:
[object Object]
signal_L
:
[object Object]
etk800_taillight_R
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{2}
lowhighbeam
:
[object Object]
signal_R
:
[object Object]
foglight
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
highbeam
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
lowbeam
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
lowfuel
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
lowpressure
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
oil
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
parkingbrake
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
rearfog
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
signal_L
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
signal_R
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
tcs
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
information
{2}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
partName
:
[object Object]
scaledragCoef
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
variables
:
[object Object]
etk800_DSE
{6}
controller
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
vehicleData
{2}
skewStiffnessFront
[1]
0
:
data.vehicleData.skewStiffnessFront = floor(measurementsTest2.maxStiffnessFront / 1000) * 1000
skewStiffnessRear
[1]
0
:
data.vehicleData.skewStiffnessRear = floor(measurementsTest2.maxStiffnessRear / 1000) * 1000
etk800_DSE_ABS
{5}
controller
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
etk800_DSE_ESC
{6}
brakeControl
{2}
useForYawControl
:
[object Object]
yawControl
{3}
PIDSettings
:
[object Object]
slipAngleThreshold
[3]
0
:
local slipAngleBrakeFactor = yawControlSlipAngleBrakingPID:get(-abs(bodySlipAngle), -controlParameters.yawControl.slipAngleThreshold, dt)
1
:
debugPacket.yawControl.slipAngleThreshold = controlParameters.yawControl.slipAngleThreshold
2
:
controlParameters.yawControl.slipAngleThreshold = jbeamData.yawControl.slipAngleThreshold or 0.1
yawAVThreshold
[2]
0
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
1
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
controller
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
motorTorqueControl
{2}
useForYawControl
:
[object Object]
yawControl
{4}
PIDSettings
:
[object Object]
slipAngleThreshold
[3]
0
:
local slipAngleBrakeFactor = yawControlSlipAngleBrakingPID:get(-abs(bodySlipAngle), -controlParameters.yawControl.slipAngleThreshold, dt)
1
:
debugPacket.yawControl.slipAngleThreshold = controlParameters.yawControl.slipAngleThreshold
2
:
controlParameters.yawControl.slipAngleThreshold = jbeamData.yawControl.slipAngleThreshold or 0.1
yawAVThreshold
[2]
0
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
1
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
yawControlledMotors
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
etk800_DSE_TC_AWD
{7}
brakeControl
{2}
tractionControl
{1}
wheelGroupSettings
:
[object Object]
useForTractionControl
:
[object Object]
controller
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
motorTorqueControl
{2}
tractionControl
{1}
wheelGroupSettings
:
[object Object]
useForTractionControl
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
tractionControl
{1}
tractionControlledMotors
:
[object Object]
etk800_DSE_drivemodes_ICE
{6}
controller
:
[object Object]
driveModes
{4}
defaultMode
:
[object Object]
defaultSettings
:
[object Object]
enabledModes
:
[object Object]
modes
{5}
comfort
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
drift
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
off
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
sport
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
ttSport
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_DSE_drivemodes_default_sport
{4}
driveModes
{1}
defaultMode
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_DSE_drivemodes_drift
{4}
driveModes
{1}
enabledModes_drift
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_DSE_drivemodes_ttSport
{4}
driveModes
{1}
enabledModes_ttSport
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_body_wagon
{12}
cameraChase
{5}
defaultRotation
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
distance
:
[object Object]
distanceMin
:
[object Object]
fov
:
[object Object]
offset
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
cameraExternal
{4}
distance
:
[object Object]
distanceMin
:
[object Object]
fov
:
[object Object]
offset
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
camerasInternal
:
[object Object]
controller
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
refNodes
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
soundscape
:
[object Object]
torsionbars
:
[object Object]
etk800_brake_F_tt
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_brake_R_tt
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_bumper_F_tt
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_bumper_R
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_bumperbar_F
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_differential_F
{8}
controller
:
[object Object]
differential_F
{3}
dynamicFriction
:
[object Object]
friction
:
[object Object]
torqueLossCoef
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
torsionReactorF
{1}
torqueReactionNodes:
:
[object Object]
etk800_differential_R
{7}
controller
:
[object Object]
differential_R
{3}
dynamicFriction
:
[object Object]
friction
:
[object Object]
torqueLossCoef
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_diffuser_R_856
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_door_FL
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_door_FR
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_door_RL_wagon
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_door_RR_wagon
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_doorglass_FL
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorglass_FR
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorglass_RL_wagon
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorglass_RR_wagon
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorpanel_FL
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorpanel_FR
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorpanel_RL
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_doorpanel_RR
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_driveshaft_F
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_driveshaft_R
{6}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
torsionReactorR
{1}
torqueReactionNodes:
:
[object Object]
etk800_exhausttips_i6
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_fender_L
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_fender_R
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_finaldrive_F_323
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
torsionReactorF
{1}
gearRatio
:
[object Object]
etk800_finaldrive_R_323
{4}
differential_R
{1}
gearRatio
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_fueltank
{6}
energyStorage
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
mainTank
{5}
breakTriggerBeam
:
[object Object]
energyType
:
[object Object]
fuel
{1}
[engineGroup]:
:
[object Object]
fuelCapacity
:
[object Object]
startingFuelCapacity
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
variables
:
[object Object]
etk800_gauges_metric
{6}
etkGauges
{1}
unitType
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
etk800_glass_sunroof_wagon
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_halfshafts_F
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
etk800_halfshafts_R
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
etk800_headlight_L
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_headlight_R
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_hood
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_licenseplate_F_alt_EU
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
licenseplateFormat
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
etk800_licenseplate_R_EU
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
licenseplateFormat
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
etk800_mirror_L
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_mirror_R
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_quarterglass_L_wagon
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_quarterglass_R_wagon
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_radiator
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
mainEngine
{8}
coolantVolume
:
[object Object]
deformGroups_radiator
:
[object Object]
radiatorArea
:
[object Object]
radiatorEffectiveness
:
[object Object]
radiatorFanMaxAirSpeed
:
[object Object]
radiatorFanTemperature
:
[object Object]
radiatorFanType
:
[object Object]
thermostatTemperature
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
etk800_roof_wagon_sun
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_seat_FL
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_seat_FR
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_seats_R
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_shifter_A
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_shock_R_tt
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_skin_drivingexperience
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
etk800_skin_interior_ttsport
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
etk800_spring_R_tt
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_steer_paddles
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_steering
{9}
hydros
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
input
{1}
FFBcoef
[2]
0
:
if v.data.input and v.data.input.FFBcoef ~= nil then
1
:
vehicleFFBForceCoef = v.data.input.FFBcoef * 1.2
partName
:
[object Object]
rails
{1}
steeringrack
{3}
capped
:
[object Object]
links:
:
[object Object]
looped
:
[object Object]
slidenodes
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
variables
:
[object Object]
etk800_strut_F_tt
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_strutbrace_F_tt
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_suspension_F
{9}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
rails
{2}
strut_FL
{3}
capped
:
[object Object]
links:
:
[object Object]
looped
:
[object Object]
strut_FR
{3}
capped
:
[object Object]
links:
:
[object Object]
looped
:
[object Object]
slidenodes
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
torsionbars
:
[object Object]
variables
:
[object Object]
etk800_suspension_R
{7}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
torsionbars
:
[object Object]
variables
:
[object Object]
etk800_swaybar_F_tt
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
torsionbars
:
[object Object]
etk800_swaybar_R_tt
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
torsionbars
:
[object Object]
etk800_tailgate
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk800_tailgateglass
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk800_taillight_L
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_taillight_R
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
props
:
[object Object]
slotType
:
[object Object]
etk800_wheeldata_F
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
etk800_wheeldata_R
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
etk800_windshield
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk_converter
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
torqueConverter
{7}
additionalEngineInertia
:
[object Object]
converterDiameter
:
[object Object]
converterStiffness
:
[object Object]
couplingAVRatio
:
[object Object]
lockupClutchTorque
:
[object Object]
stallTorqueRatio
:
[object Object]
uiName
:
[object Object]
vehicleController
{2}
torqueConverterLockupMinGear
:
[object Object]
torqueConverterLockupRPM
:
[object Object]
etk_engine_ecu_speedlimit_250
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
vehicleController
{1}
topSpeedLimit
:
[object Object]
etk_engine_i6
{9}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
mainEngine
{45}
afterFireAudibleThresholdShift
:
[object Object]
breakTriggerBeam
:
[object Object]
burnEfficiency
:
[object Object]
connectingRodDamageThreshold
:
[object Object]
cylinderWallTemperatureDamageThreshold
:
[object Object]
deformGroups
:
[object Object]
dynamicFriction
:
[object Object]
energyStorage
:
[object Object]
engineBlock
{1}
[engineGroup]:
:
[object Object]
engineBlockMaterial
:
[object Object]
engineBrakeTorque
:
[object Object]
friction
:
[object Object]
headGasketDamageThreshold
:
[object Object]
idleRPM
:
[object Object]
idleRPMStartCoef
:
[object Object]
idleRPMStartRate
:
[object Object]
inertia
:
[object Object]
instantAfterFireCoef
:
[object Object]
instantAfterFireVolumeCoef
:
[object Object]
maxOverTorqueDamage
:
[object Object]
maxRPM
:
[object Object]
maxTorqueRating
:
[object Object]
oilVolume
:
[object Object]
particulates
:
[object Object]
pistonRingDamageThreshold
:
[object Object]
radiator
{1}
[engineGroup]:
:
[object Object]
requiredEnergyType
:
[object Object]
shiftAfterFireVolumeCoef
:
[object Object]
shutOffSampleEngine
:
[object Object]
shutOffSampleExhaust
:
[object Object]
shutOffVolumeEngine
:
[object Object]
shutOffVolumeExhaust
:
[object Object]
soundConfig
:
[object Object]
soundConfigExhaust
:
[object Object]
starterSample
:
[object Object]
starterSampleExhaust
:
[object Object]
starterVolume
:
[object Object]
starterVolumeExhaust
:
[object Object]
sustainedAfterFireCoef
:
[object Object]
sustainedAfterFireVolumeCoef
:
[object Object]
thermalsEnabled
:
[object Object]
torque
:
[object Object]
torqueReactionNodes:
:
[object Object]
uiName
:
[object Object]
waterDamage
{1}
[engineGroup]:
:
[object Object]
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
soundConfig
{19}
eqFundamentalGain
[3]
0
:
local eq_e_gain = soundConfig.eqFundamentalGain or 0
1
:
local eq_e_gain = soundConfig.eqFundamentalGain or 0
2
:
local eq_e_gain = soundConfig.eqFundamentalGain or 0
eqHighFreq
[3]
0
:
local eq_d_freq = sounds.hzToFMODHz(soundConfig.eqHighFreq or 2000)
1
:
local eq_d_freq = sounds.hzToFMODHz(soundConfig.eqHighFreq or 2000)
2
:
local eq_d_freq = sounds.hzToFMODHz(soundConfig.eqHighFreq or 2000)
eqHighGain
[3]
0
:
local eq_d_gain = soundConfig.eqHighGain or 0
1
:
local eq_d_gain = soundConfig.eqHighGain or 0
2
:
local eq_d_gain = soundConfig.eqHighGain or 0
eqHighWidth
[3]
0
:
local eq_d_reso = soundConfig.eqHighWidth or 0
1
:
local eq_d_reso = soundConfig.eqHighWidth or 0
2
:
local eq_d_reso = soundConfig.eqHighWidth or 0
eqLowFreq
[3]
0
:
local eq_c_freq = sounds.hzToFMODHz(soundConfig.eqLowFreq or 500)
1
:
local eq_c_freq = sounds.hzToFMODHz(soundConfig.eqLowFreq or 500)
2
:
local eq_c_freq = sounds.hzToFMODHz(soundConfig.eqLowFreq or 500)
eqLowGain
[3]
0
:
local eq_c_gain = soundConfig.eqLowGain or 0
1
:
local eq_c_gain = soundConfig.eqLowGain or 0
2
:
local eq_c_gain = soundConfig.eqLowGain or 0
eqLowWidth
[3]
0
:
local eq_c_reso = soundConfig.eqLowWidth or 0
1
:
local eq_c_reso = soundConfig.eqLowWidth or 0
2
:
local eq_c_reso = soundConfig.eqLowWidth or 0
fundamentalFrequencyCylinderCount
[3]
0
:
local fundamentalFrequencyCylinderCount = soundConfig.fundamentalFrequencyCylinderCount or 6
1
:
local fundamentalFrequencyCylinderCount = soundConfig.fundamentalFrequencyCylinderCount or 6
2
:
local fundamentalFrequencyCylinderCount = soundConfig.fundamentalFrequencyCylinderCount or 6
highShelfFreq
[2]
0
:
local eq_b_freq = sounds.hzToFMODHz(soundConfig.highShelfFreq or soundConfig.highCutFreq or 10000)
1
:
local eq_b_freq = sounds.hzToFMODHz(soundConfig.highShelfFreq or soundConfig.highCutFreq or 10000)
highShelfGain
[2]
0
:
local eq_b_gain = soundConfig.highShelfGain or 0
1
:
local eq_b_gain = soundConfig.highShelfGain or 0
intakeMuffling
[1]
0
:
local intakeMuffling = soundConfig.intakeMuffling or 1
lowShelfFreq
[2]
0
:
local eq_a_freq = sounds.hzToFMODHz(soundConfig.lowShelfFreq or soundConfig.lowCutFreq or 20)
1
:
local eq_a_freq = sounds.hzToFMODHz(soundConfig.lowShelfFreq or soundConfig.lowCutFreq or 20)
lowShelfGain
[2]
0
:
local eq_a_gain = soundConfig.lowShelfGain or 0
1
:
local eq_a_gain = soundConfig.lowShelfGain or 0
mainGain
[3]
0
:
local main_gain = soundConfig.mainGain or 0
1
:
device.exhaustMainGain = soundConfig.mainGain or 0
2
:
local main_gain = soundConfig.mainGain or 0
maxLoadMix
[3]
0
:
device.soundMaxLoadMix = soundConfig.maxLoadMix or 1
1
:
device.soundMaxLoadMixExhaust = soundConfig.maxLoadMix
2
:
device.soundMaxLoadMix = soundConfig.maxLoadMix or 1
minLoadMix
[3]
0
:
device.soundMinLoadMix = soundConfig.minLoadMix or 0
1
:
device.soundMinLoadMixExhaust = soundConfig.minLoadMix
2
:
device.soundMinLoadMix = soundConfig.minLoadMix or 0
offLoadGain
[3]
0
:
local offLoadGain = soundConfig.offLoadGain or 1
1
:
local offLoadGain = soundConfig.offLoadGain or 1
2
:
local offLoadGain = soundConfig.offLoadGain or 1
onLoadGain
[3]
0
:
local onLoadGain = soundConfig.onLoadGain or 1
1
:
local onLoadGain = soundConfig.onLoadGain or 1
2
:
local onLoadGain = soundConfig.onLoadGain or 1
sampleName
[3]
0
:
local sampleName = soundConfig.sampleName
1
:
local sampleName = soundConfig.sampleName
2
:
local sampleName = soundConfig.sampleName
soundConfigExhaust
{18}
eqFundamentalGain
:
[object Object]
eqHighFreq
:
[object Object]
eqHighGain
:
[object Object]
eqHighWidth
:
[object Object]
eqLowFreq
:
[object Object]
eqLowGain
:
[object Object]
eqLowWidth
:
[object Object]
fundamentalFrequencyCylinderCount
:
[object Object]
highShelfFreq
:
[object Object]
highShelfGain
:
[object Object]
lowShelfFreq
:
[object Object]
lowShelfGain
:
[object Object]
mainGain
:
[object Object]
maxLoadMix
:
[object Object]
minLoadMix
:
[object Object]
offLoadGain
:
[object Object]
onLoadGain
:
[object Object]
sampleName
:
[object Object]
vehicleController
{4}
clutchLaunchStartRPM
:
[object Object]
clutchLaunchTargetRPM
:
[object Object]
highShiftDownRPM
:
[object Object]
highShiftUpRPM
:
[object Object]
etk_engine_i6_ecu
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
mainEngine
{3}
idleRPM
:
[object Object]
revLimiterRPM
:
[object Object]
revLimiterType
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk_engine_i6_internals
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk_enginemounts
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk_exhaust_i6_petrol
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
mainEngine
{1}
torqueModExhaust
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk_intake_i6
{3}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
slotType
:
[object Object]
etk_oilpan_i6
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
mainEngine
{4}
deformGroups_oilPan
:
[object Object]
oilVolume
:
[object Object]
oilpanMaximumSafeG
:
[object Object]
oilpanNodes:
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
etk_transfer_case_AWD
{5}
controller
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
etk_transmission_8A
{7}
gearbox
{10}
dynamicFriction
:
[object Object]
friction
:
[object Object]
gearChangeTime
:
[object Object]
gearRatios
:
[object Object]
gearboxNode:
:
[object Object]
oneWayViscousCoef
:
[object Object]
parkLockTorque
:
[object Object]
shiftEfficiency
:
[object Object]
torqueLossCoef
:
[object Object]
uiName
:
[object Object]
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
powertrain
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
vehicleController
{15}
aggressionHoldOffThrottleDelay
:
[object Object]
aggressionSmoothingDown
:
[object Object]
aggressionSmoothingUp
:
[object Object]
automaticModes
:
[object Object]
calculateOptimalLoadShiftPoints
:
[object Object]
gearboxDecisionSmoothingDown
:
[object Object]
gearboxDecisionSmoothingUp
:
[object Object]
lowShiftDownRPM
:
[object Object]
lowShiftUpRPM
:
[object Object]
maxGearChangeTime
:
[object Object]
minGearChangeTime
:
[object Object]
shiftDownRPMOffsetCoef
:
[object Object]
sportGearChangeTime
:
[object Object]
throttleCoefWhileShifting
:
[object Object]
transmissionGearChangeDelay
:
[object Object]
etk_wheel_02a_18x9_F
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
etk_wheel_02a_18x9_R
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
slots
:
[object Object]
license_plate_germany_2_1
{4}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
licenseplate_path
:
[object Object]
partName
:
[object Object]
slotType
:
[object Object]
soundscape_horn_7
{4}
information
{2}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
partName
:
[object Object]
slotType
:
[object Object]
soundscape
:
[object Object]
tire_F_245_40_18_sport
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
variables
:
[object Object]
tire_R_245_40_18_sport
{5}
information
{3}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
value
[1]
0
:
partValue = part.information.value or partValue
partName
:
[object Object]
pressureWheels
:
[object Object]
slotType
:
[object Object]
variables
:
[object Object]
brakeControl
{4}
tractionControl
{1}
wheelGroupSettings
:
[object Object]
useForTractionControl
:
[object Object]
useForYawControl
:
[object Object]
yawControl
{3}
PIDSettings
:
[object Object]
slipAngleThreshold
[3]
0
:
local slipAngleBrakeFactor = yawControlSlipAngleBrakingPID:get(-abs(bodySlipAngle), -controlParameters.yawControl.slipAngleThreshold, dt)
1
:
debugPacket.yawControl.slipAngleThreshold = controlParameters.yawControl.slipAngleThreshold
2
:
controlParameters.yawControl.slipAngleThreshold = jbeamData.yawControl.slipAngleThreshold or 0.1
yawAVThreshold
[2]
0
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
1
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
cameraData
{4}
chase
{5}
defaultRotation
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
distance
:
[object Object]
distanceMin
:
[object Object]
fov
:
[object Object]
offset
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
onboard
:
[object Object]
orbit
{4}
distance
:
[object Object]
distanceMin
:
[object Object]
fov
:
[object Object]
offset
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
relative
:
[object Object]
cameras
{4}
chase
{5}
defaultRotation
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
distance
:
[object Object]
distanceMin
:
[object Object]
fov
:
[object Object]
offset
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
onboard
:
[object Object]
orbit
{4}
distance
:
[object Object]
distanceMin
:
[object Object]
fov
:
[object Object]
offset
{3}
x
:
[object Object]
y
:
[object Object]
z
:
[object Object]
relative
:
[object Object]
controller
:
[object Object]
differential_F
{3}
dynamicFriction
:
[object Object]
friction
:
[object Object]
torqueLossCoef
:
[object Object]
differential_R
{4}
dynamicFriction
:
[object Object]
friction
:
[object Object]
gearRatio
:
[object Object]
torqueLossCoef
:
[object Object]
directoriesLoaded
:
[object Object]
driveModes
{6}
defaultMode
:
[object Object]
defaultSettings
:
[object Object]
enabledModes
:
[object Object]
enabledModes_drift
:
[object Object]
enabledModes_ttSport
:
[object Object]
modes
{5}
comfort
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
drift
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
off
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
sport
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
ttSport
{3}
name
:
[object Object]
order
:
[object Object]
settings
:
[object Object]
energyStorage
:
[object Object]
etkGauges
{1}
unitType
:
[object Object]
format
[1]
0
:
vdataStage1.vdata.format = "parsed"
gearbox
{10}
dynamicFriction
:
[object Object]
friction
:
[object Object]
gearChangeTime
:
[object Object]
gearRatios
:
[object Object]
gearboxNode_nodes
:
[object Object]
oneWayViscousCoef
:
[object Object]
parkLockTorque
:
[object Object]
shiftEfficiency
:
[object Object]
torqueLossCoef
:
[object Object]
uiName
:
[object Object]
glowMap
{26}
abs
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
checkengine
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
esc
{3}
off
:
[object Object]
on
[3]
0
:
if v.data.escConfig then
1
:
v.data.esc = v.data.escConfig
2
:
local escConfigurations = {}
simpleFunction
:
[object Object]
etk800_chmsl
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
brakelights
:
[object Object]
etk800_foglight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
fog
:
[object Object]
etk800_gauges
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
etk800_headlight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{2}
highbeam
:
[object Object]
lowbeam
:
[object Object]
etk800_parkinglight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
parking
:
[object Object]
etk800_reverselight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
reverse
:
[object Object]
etk800_runninglight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
running
:
[object Object]
etk800_signal_L
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
signal_L
:
[object Object]
etk800_signal_R
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
signal_R
:
[object Object]
etk800_taillight
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{1}
brakelights
:
[object Object]
etk800_taillight_L
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{2}
lowhighbeam
:
[object Object]
signal_L
:
[object Object]
etk800_taillight_R
{4}
off
:
[object Object]
on
:
[object Object]
on_intense
:
[object Object]
simpleFunction
{2}
lowhighbeam
:
[object Object]
signal_R
:
[object Object]
foglight
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
highbeam
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
lowbeam
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
lowfuel
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
lowpressure
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
oil
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
parkingbrake
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
rearfog
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
signal_L
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
signal_R
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
tcs
{3}
off
:
[object Object]
on
:
[object Object]
simpleFunction
:
[object Object]
groups
{68}
etk800_body
:
[object Object]
etk800_bumper_F
:
[object Object]
etk800_bumper_R
:
[object Object]
etk800_bumperbar
:
[object Object]
etk800_caliper_F
:
[object Object]
etk800_dash
:
[object Object]
etk800_diff_F
:
[object Object]
etk800_diff_R
:
[object Object]
etk800_door_FL
:
[object Object]
etk800_door_FR
:
[object Object]
etk800_door_RL
:
[object Object]
etk800_door_RR
:
[object Object]
etk800_engine_bay
:
[object Object]
etk800_exhaust_L
:
[object Object]
etk800_exhaust_R
:
[object Object]
etk800_fender_L
:
[object Object]
etk800_fender_R
:
[object Object]
etk800_floor
:
[object Object]
etk800_headlight_L
:
[object Object]
etk800_headlight_R
:
[object Object]
etk800_hood
:
[object Object]
etk800_hub_F
:
[object Object]
etk800_hub_R
:
[object Object]
etk800_lowerarm_F_a
:
[object Object]
etk800_lowerarm_F_b
:
[object Object]
etk800_lowerarm_R
:
[object Object]
etk800_mirror_L
:
[object Object]
etk800_mirror_R
:
[object Object]
etk800_roof
:
[object Object]
etk800_seat_FL
:
[object Object]
etk800_seat_FR
:
[object Object]
etk800_seat_R
:
[object Object]
etk800_shock_R
:
[object Object]
etk800_spring_R
:
[object Object]
etk800_steeringbox
:
[object Object]
etk800_strut_F
:
[object Object]
etk800_strutbar
:
[object Object]
etk800_subframe_F
:
[object Object]
etk800_subframe_R
:
[object Object]
etk800_swaybar_F
:
[object Object]
etk800_swaybar_R
:
[object Object]
etk800_tailgate
:
[object Object]
etk800_taillight_L
:
[object Object]
etk800_taillight_R
:
[object Object]
etk800_tierod_F
:
[object Object]
etk800_tierod_R
:
[object Object]
etk800_tubs
:
[object Object]
etk800_upperarm_R
:
[object Object]
etk800_wheelarm_F
:
[object Object]
etk800_windshield
:
[object Object]
etk_airbox
:
[object Object]
etk_engine
:
[object Object]
etk_header
:
[object Object]
etk_radiator
:
[object Object]
etk_transmission
:
[object Object]
gps
:
[object Object]
tire_FL
:
[object Object]
tire_FR
:
[object Object]
tire_RL
:
[object Object]
tire_RR
:
[object Object]
wheel_FL
:
[object Object]
wheel_FR
:
[object Object]
wheel_RL
:
[object Object]
wheel_RR
:
[object Object]
wheelhub_FL
:
[object Object]
wheelhub_FR
:
[object Object]
wheelhub_RL
:
[object Object]
wheelhub_RR
:
[object Object]
hydros
:
[object Object]
information
{2}
authors
[1]
0
:
authors = part.information.authors or "",
name
[3]
0
:
name = part.information.name or name
1
:
return {trackWidth = trackWidth, wheelBase = wheelBase, objectID = objectId, vehicleName = v.data.information.name}
2
:
description = part.information.name or "",
input
{2}
FFBcoef
[2]
0
:
if v.data.input and v.data.input.FFBcoef ~= nil then
1
:
vehicleFFBForceCoef = v.data.input.FFBcoef * 1.2
steeringWheelLock
[3]
0
:
electrics.values.steering = -steeringHydro.hydroDirState * v.data.input.steeringWheelLock
1
:
if v.data.input and v.data.input.steeringWheelLock ~= nil then
2
:
vehicleSteeringWheelLock = v.data.input.steeringWheelLock
mainEngine
{59}
afterFireAudibleThresholdShift
:
[object Object]
breakTriggerBeam
:
[object Object]
burnEfficiency
:
[object Object]
connectingRodDamageThreshold
:
[object Object]
coolantVolume
:
[object Object]
cylinderWallTemperatureDamageThreshold
:
[object Object]
deformGroups
:
[object Object]
deformGroups_oilPan
:
[object Object]
deformGroups_radiator
:
[object Object]
dynamicFriction
:
[object Object]
energyStorage
:
[object Object]
engineBlock
{1}
[engineGroup]:
:
[object Object]
engineBlockMaterial
:
[object Object]
engineBrakeTorque
:
[object Object]
friction
:
[object Object]
headGasketDamageThreshold
:
[object Object]
idleRPM
:
[object Object]
idleRPMStartCoef
:
[object Object]
idleRPMStartRate
:
[object Object]
inertia
:
[object Object]
instantAfterFireCoef
:
[object Object]
instantAfterFireVolumeCoef
:
[object Object]
maxOverTorqueDamage
:
[object Object]
maxRPM
:
[object Object]
maxTorqueRating
:
[object Object]
oilVolume
:
[object Object]
oilpanMaximumSafeG
:
[object Object]
oilpanNodes_nodes
:
[object Object]
particulates
:
[object Object]
pistonRingDamageThreshold
:
[object Object]
radiator
{1}
[engineGroup]:
:
[object Object]
radiatorArea
:
[object Object]
radiatorEffectiveness
:
[object Object]
radiatorFanMaxAirSpeed
:
[object Object]
radiatorFanTemperature
:
[object Object]
radiatorFanType
:
[object Object]
requiredEnergyType
:
[object Object]
revLimiterRPM
:
[object Object]
revLimiterType
:
[object Object]
shiftAfterFireVolumeCoef
:
[object Object]
shutOffSampleEngine
:
[object Object]
shutOffSampleExhaust
:
[object Object]
shutOffVolumeEngine
:
[object Object]
shutOffVolumeExhaust
:
[object Object]
soundConfig
:
[object Object]
soundConfigExhaust
:
[object Object]
starterSample
:
[object Object]
starterSampleExhaust
:
[object Object]
starterVolume
:
[object Object]
starterVolumeExhaust
:
[object Object]
sustainedAfterFireCoef
:
[object Object]
sustainedAfterFireVolumeCoef
:
[object Object]
thermalsEnabled
:
[object Object]
thermostatTemperature
:
[object Object]
torque
:
[object Object]
torqueModExhaust
:
[object Object]
torqueReactionNodes_nodes
:
[object Object]
uiName
:
[object Object]
waterDamage
{1}
[engineGroup]:
:
[object Object]
mainTank
{5}
breakTriggerBeam
:
[object Object]
energyType
:
[object Object]
fuel
{1}
[engineGroup]:
:
[object Object]
fuelCapacity
:
[object Object]
startingFuelCapacity
:
[object Object]
maxIDs
{14}
camerasInternal
:
[object Object]
controller
:
[object Object]
energyStorage
:
[object Object]
hydros
:
[object Object]
powertrain
:
[object Object]
pressureWheels
:
[object Object]
props
:
[object Object]
refNodes
:
[object Object]
slidenodes
:
[object Object]
slots
:
[object Object]
soundscape
:
[object Object]
torsionbars
:
[object Object]
variables
:
[object Object]
wheels
[1]
0
:
vehicle.maxIDs.wheels = nil
motorTorqueControl
{4}
tractionControl
{1}
wheelGroupSettings
:
[object Object]
useForTractionControl
:
[object Object]
useForYawControl
:
[object Object]
yawControl
{4}
PIDSettings
:
[object Object]
slipAngleThreshold
[3]
0
:
local slipAngleBrakeFactor = yawControlSlipAngleBrakingPID:get(-abs(bodySlipAngle), -controlParameters.yawControl.slipAngleThreshold, dt)
1
:
debugPacket.yawControl.slipAngleThreshold = controlParameters.yawControl.slipAngleThreshold
2
:
controlParameters.yawControl.slipAngleThreshold = jbeamData.yawControl.slipAngleThreshold or 0.1
yawAVThreshold
[2]
0
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
1
:
debugPacket.yawControl.yawAVThreshold = controlParameters.yawControl.yawAvThreshold
yawControlledMotors
:
[object Object]
options
{11}
beamDamp
:
[object Object]
beamDeform
:
[object Object]
beamSpring
[1]
0
:
local spring = snode.spring or vehicle.options.beamSpring
beamStrength
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
nodeWeight
[1]
0
:
nodeWeight = vehicle.options.nodeWeight
partName
:
[object Object]
scaledragCoef
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
powertrain
:
[object Object]
props
:
[object Object]
rails
{4}
cids
:
[object Object]
steeringrack
{4}
capped
:
[object Object]
cid
:
[object Object]
links:
:
[object Object]
looped
:
[object Object]
strut_FL
{4}
capped
:
[object Object]
cid
:
[object Object]
links:
:
[object Object]
looped
:
[object Object]
strut_FR
{4}
capped
:
[object Object]
cid
:
[object Object]
links:
:
[object Object]
looped
:
[object Object]
refNodes
:
[object Object]
slidenodes
:
[object Object]
slots
:
[object Object]
soundConfig
{19}
eqFundamentalGain
[3]
0
:
local eq_e_gain = soundConfig.eqFundamentalGain or 0
1
:
local eq_e_gain = soundConfig.eqFundamentalGain or 0
2
:
local eq_e_gain = soundConfig.eqFundamentalGain or 0
eqHighFreq
[3]
0
:
local eq_d_freq = sounds.hzToFMODHz(soundConfig.eqHighFreq or 2000)
1
:
local eq_d_freq = sounds.hzToFMODHz(soundConfig.eqHighFreq or 2000)
2
:
local eq_d_freq = sounds.hzToFMODHz(soundConfig.eqHighFreq or 2000)
eqHighGain
[3]
0
:
local eq_d_gain = soundConfig.eqHighGain or 0
1
:
local eq_d_gain = soundConfig.eqHighGain or 0
2
:
local eq_d_gain = soundConfig.eqHighGain or 0
eqHighWidth
[3]
0
:
local eq_d_reso = soundConfig.eqHighWidth or 0
1
:
local eq_d_reso = soundConfig.eqHighWidth or 0
2
:
local eq_d_reso = soundConfig.eqHighWidth or 0
eqLowFreq
[3]
0
:
local eq_c_freq = sounds.hzToFMODHz(soundConfig.eqLowFreq or 500)
1
:
local eq_c_freq = sounds.hzToFMODHz(soundConfig.eqLowFreq or 500)
2
:
local eq_c_freq = sounds.hzToFMODHz(soundConfig.eqLowFreq or 500)
eqLowGain
[3]
0
:
local eq_c_gain = soundConfig.eqLowGain or 0
1
:
local eq_c_gain = soundConfig.eqLowGain or 0
2
:
local eq_c_gain = soundConfig.eqLowGain or 0
eqLowWidth
[3]
0
:
local eq_c_reso = soundConfig.eqLowWidth or 0
1
:
local eq_c_reso = soundConfig.eqLowWidth or 0
2
:
local eq_c_reso = soundConfig.eqLowWidth or 0
fundamentalFrequencyCylinderCount
[3]
0
:
local fundamentalFrequencyCylinderCount = soundConfig.fundamentalFrequencyCylinderCount or 6
1
:
local fundamentalFrequencyCylinderCount = soundConfig.fundamentalFrequencyCylinderCount or 6
2
:
local fundamentalFrequencyCylinderCount = soundConfig.fundamentalFrequencyCylinderCount or 6
highShelfFreq
[2]
0
:
local eq_b_freq = sounds.hzToFMODHz(soundConfig.highShelfFreq or soundConfig.highCutFreq or 10000)
1
:
local eq_b_freq = sounds.hzToFMODHz(soundConfig.highShelfFreq or soundConfig.highCutFreq or 10000)
highShelfGain
[2]
0
:
local eq_b_gain = soundConfig.highShelfGain or 0
1
:
local eq_b_gain = soundConfig.highShelfGain or 0
intakeMuffling
[1]
0
:
local intakeMuffling = soundConfig.intakeMuffling or 1
lowShelfFreq
[2]
0
:
local eq_a_freq = sounds.hzToFMODHz(soundConfig.lowShelfFreq or soundConfig.lowCutFreq or 20)
1
:
local eq_a_freq = sounds.hzToFMODHz(soundConfig.lowShelfFreq or soundConfig.lowCutFreq or 20)
lowShelfGain
[2]
0
:
local eq_a_gain = soundConfig.lowShelfGain or 0
1
:
local eq_a_gain = soundConfig.lowShelfGain or 0
mainGain
[3]
0
:
local main_gain = soundConfig.mainGain or 0
1
:
device.exhaustMainGain = soundConfig.mainGain or 0
2
:
local main_gain = soundConfig.mainGain or 0
maxLoadMix
[3]
0
:
device.soundMaxLoadMix = soundConfig.maxLoadMix or 1
1
:
device.soundMaxLoadMixExhaust = soundConfig.maxLoadMix
2
:
device.soundMaxLoadMix = soundConfig.maxLoadMix or 1
minLoadMix
[3]
0
:
device.soundMinLoadMix = soundConfig.minLoadMix or 0
1
:
device.soundMinLoadMixExhaust = soundConfig.minLoadMix
2
:
device.soundMinLoadMix = soundConfig.minLoadMix or 0
offLoadGain
[3]
0
:
local offLoadGain = soundConfig.offLoadGain or 1
1
:
local offLoadGain = soundConfig.offLoadGain or 1
2
:
local offLoadGain = soundConfig.offLoadGain or 1
onLoadGain
[3]
0
:
local onLoadGain = soundConfig.onLoadGain or 1
1
:
local onLoadGain = soundConfig.onLoadGain or 1
2
:
local onLoadGain = soundConfig.onLoadGain or 1
sampleName
[3]
0
:
local sampleName = soundConfig.sampleName
1
:
local sampleName = soundConfig.sampleName
2
:
local sampleName = soundConfig.sampleName
soundConfigExhaust
{18}
eqFundamentalGain
:
[object Object]
eqHighFreq
:
[object Object]
eqHighGain
:
[object Object]
eqHighWidth
:
[object Object]
eqLowFreq
:
[object Object]
eqLowGain
:
[object Object]
eqLowWidth
:
[object Object]
fundamentalFrequencyCylinderCount
:
[object Object]
highShelfFreq
:
[object Object]
highShelfGain
:
[object Object]
lowShelfFreq
:
[object Object]
lowShelfGain
:
[object Object]
mainGain
:
[object Object]
maxLoadMix
:
[object Object]
minLoadMix
:
[object Object]
offLoadGain
:
[object Object]
onLoadGain
:
[object Object]
sampleName
:
[object Object]
soundscape
{9}
LightOff
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
LightOn
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
handbrakeDisengaged
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
handbrakeEngaging
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
horn
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
indLoop1
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
indLoop2
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
indicatorStart
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
indicatorStop
{10}
cid
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
name
:
[object Object]
node
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
src
:
[object Object]
torqueConverter
{7}
additionalEngineInertia
:
[object Object]
converterDiameter
:
[object Object]
converterStiffness
:
[object Object]
couplingAVRatio
:
[object Object]
lockupClutchTorque
:
[object Object]
stallTorqueRatio
:
[object Object]
uiName
:
[object Object]
torsionReactorF
{2}
gearRatio
:
[object Object]
torqueReactionNodes_nodes
:
[object Object]
torsionReactorR
{1}
torqueReactionNodes_nodes
:
[object Object]
torsionbars
:
[object Object]
tractionControl
{1}
tractionControlledMotors
:
[object Object]
variables
{13}
$brakestrength
{20}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$camber_FR
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$camber_RR
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$caster_FR
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$ffbstrength
{20}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$fuel
{21}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$steer_center_F
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$tirepressure_F
{23}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
nodeOffset
{3}
x
[3]
0
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
1
:
v.pos.x = v.pos.x + fsign(v.pos.x) * v.nodeOffset.x * nodeOffsetCoef
2
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
y
[3]
0
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
1
:
v.pos.y = v.pos.y + v.nodeOffset.y * nodeOffsetCoef
2
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
z
[3]
0
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
1
:
v.pos.z = v.pos.z + v.nodeOffset.z * nodeOffsetCoef
2
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$tirepressure_R
{23}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
nodeOffset
{3}
x
[3]
0
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
1
:
v.pos.x = v.pos.x + fsign(v.pos.x) * v.nodeOffset.x * nodeOffsetCoef
2
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
y
[3]
0
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
1
:
v.pos.y = v.pos.y + v.nodeOffset.y * nodeOffsetCoef
2
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
z
[3]
0
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
1
:
v.pos.z = v.pos.z + v.nodeOffset.z * nodeOffsetCoef
2
:
if v.nodeOffset and type(v.nodeOffset) == 'table' and v.nodeOffset.x and v.nodeOffset.y and v.nodeOffset.z then
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$toe_FR
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$toe_RR
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$trackoffset_F
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
$trackoffset_R
{22}
category
:
[object Object]
cid
:
[object Object]
default
:
[object Object]
description
:
[object Object]
licenseplateFormat
:
[object Object]
licenseplate_path
:
[object Object]
max
:
[object Object]
maxDis
:
[object Object]
min
:
[object Object]
minDis
:
[object Object]
name
:
[object Object]
partName
:
[object Object]
partOrigin
:
[object Object]
skinName
:
[object Object]
slotType
:
[object Object]
step
:
[object Object]
stepDis
:
[object Object]
subCategory
:
[object Object]
title
:
[object Object]
type
:
[object Object]
unit
:
[object Object]
val
:
[object Object]
vehicleController
{22}
aggressionHoldOffThrottleDelay
:
[object Object]
aggressionSmoothingDown
:
[object Object]
aggressionSmoothingUp
:
[object Object]
automaticModes
:
[object Object]
calculateOptimalLoadShiftPoints
:
[object Object]
clutchLaunchStartRPM
:
[object Object]
clutchLaunchTargetRPM
:
[object Object]
gearboxDecisionSmoothingDown
:
[object Object]
gearboxDecisionSmoothingUp
:
[object Object]
highShiftDownRPM
:
[object Object]
highShiftUpRPM
:
[object Object]
lowShiftDownRPM
:
[object Object]
lowShiftUpRPM
:
[object Object]
maxGearChangeTime
:
[object Object]
minGearChangeTime
:
[object Object]
shiftDownRPMOffsetCoef
:
[object Object]
sportGearChangeTime
:
[object Object]
throttleCoefWhileShifting
:
[object Object]
topSpeedLimit
:
[object Object]
torqueConverterLockupMinGear
:
[object Object]
torqueConverterLockupRPM
:
[object Object]
transmissionGearChangeDelay
:
[object Object]
vehicleData
{2}
skewStiffnessFront
[1]
0
:
data.vehicleData.skewStiffnessFront = floor(measurementsTest2.maxStiffnessFront / 1000) * 1000
skewStiffnessRear
[1]
0
:
data.vehicleData.skewStiffnessRear = floor(measurementsTest2.maxStiffnessRear / 1000) * 1000
vehicleDirectory
[3]
0
:
filename = v.data.vehicleDirectory .. "/vehicle.save.json"
1
:
save.model = v.data.vehicleDirectory:gsub("vehicles/", ""):gsub("/", "")
2
:
save.vehicleDirectory = v.data.vehicleDirectory
wheels
:
[object Object]
vehicleDirectory
:
[object Object]
loadVehicleStage2(vdataStage1)
[1]
0
:
vehicle = v.loadVehicleStage2(initData)
vehicleCertifications
{3}
getCertifications()
:
[object Object]
init()
[1]
0
:
vehicleCertifications.init()
reset()
[1]
0
:
vehicleCertifications.reset()
vehiclePath
[3]
0
:
log("E", "", "Vehicle "..dumps(vehiclePath).." is using input.keys["..dumps(key).."]. This may be removed in the next update; the creator of that vehicle should instead use \"vehicle-specific bindings\".")
1
:
vehiclePath = nil
2
:
vehiclePath = path
vmType
[3]
0
:
if vmType == 'game' then
1
:
if vmType == 'game' then
2
:
if vmType == 'game' then
wheels
{25}
rotatorCount
:
[object Object]
wheelCount
[3]
0
:
wheelCount = wheels.wheelCount
1
:
if wheels.wheelCount <= 0 then
2
:
if wheels.wheelCount <= 0 then
wheelIDs
{4}
FL
:
[object Object]
FR
:
[object Object]
RL
:
[object Object]
RR
:
[object Object]
wheelPower
:
[object Object]
wheelRotatorCount
[3]
0
:
for i = 0, wheels.wheelRotatorCount - 1, 1 do
1
:
wheelRotatorCountDec = wheels.wheelRotatorCount - 1
2
:
for i = 0, wheels.wheelRotatorCount - 1 do
wheelRotators
:
[object Object]
wheelTorque
:
[object Object]
wheels
:
[object Object]
beamBroke(id)
[1]
0
:
wheels.beamBroke(id)
init()
[1]
0
:
wheels.init()
initSecondStage()
[1]
0
:
wheels.initSecondStage()
initSounds()
[1]
0
:
wheels.initSounds()
isPhysicsStepUsed()
:
[object Object]
nodeCollision(p)
[1]
0
:
wheels.nodeCollision(p)
reset()
[1]
0
:
wheels.reset()
resetABSBehavior()
:
[object Object]
resetSecondStage()
[1]
0
:
wheels.resetSecondStage()
scaleBrakeTorque(coef)
:
[object Object]
setABSBehavior(behavior)
[2]
0
:
wheels.setABSBehavior("arcade")
1
:
wheels.setABSBehavior("arcade")
setWheelRotatorType(wheelID, rotatorType)
[1]
0
:
wheels.setWheelRotatorType(device.wheel.wheelID, "rotator")
updateGFX(dt)
[1]
0
:
wheels.updateGFX(dtSim)
updateGFXreset(dt)
[1]
0
:
wheels.updateGFXreset() -- must be last
updateThermalsGFX()
:
[object Object]
updateWheelTorques(dt)
[1]
0
:
wheels.updateWheelTorques(dtSim)
updateWheelVelocities(dt)
[1]
0
:
wheels.updateWheelVelocities(dtSim)
PSItoPascal(psi)
[1]
0
:
triangle.pressure = math.max(triangle.pressure or PSItoPascal(triangle.pressurePSI), 0) -- From PSI to Pa
arrayConcat(dst, src)
[3]
0
:
arrayConcat(vehicle.engine.waterDamage.nodes, vehicle.engine.waterDamage._group_nodes or {})
1
:
arrayConcat(vehicle.engine.waterDamage.nodes, vehicle.engine.waterDamage._engineGroup_nodes or {})
2
:
arrayConcat(endNodes, childEndNodes)
arrayFindValueIndex(t, val)
[1]
0
:
local validNode = (i == 1 and path[i] == node.edgeNodes[1]) or arrayFindValueIndex(path, node.edgeNodes[2]) -- two steps just to be safe
arrayShuffle(array)
[1]
0
:
local shuffledBreakGroups = arrayShuffle(partBreakGroups)
assert(*)
[3]
0
:
assert(add or rem, "table contains neither 'add' nor 'remove'")
1
:
assert(newValue ~= nil, "cannot add 'nil' as value")
2
:
assert(pos >= 1 and pos <= #self.values, "illegal position")
cardinalSpline(p0, p1, p2, p3, t, s, d1, d2, d3)
[3]
0
:
return cardinalSpline(p0, p1, p2, p3, t, s or 0.5, 1, 1, 1)
1
:
return cardinalSpline(p0, p1, p2, p3, t, s or 0.5, p0:distance(p1), p1:distance(p2), p2:distance(p3))
2
:
return cardinalSpline(p0, p1, p2, p3, t, s or 0.5, sqrt(p0:distance(p1)), sqrt(p1:distance(p2)), sqrt(p2:distance(p3)))
clamp(x, minValue, maxValue)
[3]
0
:
local pbrake = clamp(sign2(aiDirVec:dot(gravityDir) - 0.17), 0, 1) -- apply parking brake if reversing on an incline >~ 10 deg
1
:
driveCar(-sign2(dirDiff), 0, clamp(0.05 * speedDif + 0.01 * threewayturn.speedDifInt, 0, 1), pbrake)
2
:
local xnorm = clamp(aiXnormOnSeg, 0, 1)
closestLinePoints(l1p0, l1p1, l2p0, l2p1)
[2]
0
:
local rnorm, vnorm = closestLinePoints(n1ext, n2ext, plPosFront, plPosRear)
1
:
local xnorm = closestLinePoints(playerNodePos1, playerNodePos1 + targetLineDir, player.pos, player.pos + player.dirVec)
collectgarbage(*)
[3]
0
:
if gcrunning then collectgarbage("restart")
1
:
gcrunning = collectgarbage("isrunning")
2
:
collectgarbage("stop")
color(r, g, b, a)
[3]
0
:
--obj.debugDrawProxy:drawSphere(0.05, copVec:toFloat3(), color(0,0,255,255))
1
:
--obj.debugDrawProxy:drawSphere(0.05, cog:toFloat3(), color(255,0,255,255))
2
:
--obj.debugDrawProxy:drawSphere(0.02, rearAxlePos:toFloat3(), color(255,0,0,255))
createCurve(points, returnArray)
[3]
0
:
local rawBaseCurve = createCurve(rawBasePoints)
1
:
rawTorqueMultCurve = createCurve(rawTorqueMultPoints)
2
:
rawIntakeCurve = createCurve(rawIntakePoints)
debugPoll()
[1]
0
:
debugPoll()
deepcopy(object)
[3]
0
:
initialControlParameters = deepcopy(controlParameters)
1
:
initialControlParameters = deepcopy(controlParameters)
2
:
data = deepcopy(_data)
deserialize(s)
[3]
0
:
deserializePackages(deserialize(s))
1
:
-- da = deserialize(s)
2
:
-- if deserialize(serialize(nil)) ~= nil then print "serialize with nil fails to work corectly"
deserializePackages(data, filter)
[1]
0
:
deserializePackages(deserialize(s))
detectGlobalWrites()
[1]
0
:
detectGlobalWrites()
dump()
[3]
0
:
dump(currentRoute)
1
:
dump(data)
2
:
-- dump(...)
dumpToFile(filename)
[1]
0
:
dumpToFile("partDamage.json", damageData)
dumps()
[3]
0
:
--print('headers:' .. dumps(headers))
1
:
obj:queueGameEngineLua(string.format(callback, obj:getId(), dumps(cOff)))
2
:
if #planets > 0 then print('obj:setPlanets(' .. dumps(planets) .. ')')
dumpsz(o, depth)
[3]
0
:
log('E', "", "Slots section in file " .. tostring(sourceFilename) .. " invalid. Unable to recover: " .. dumpsz(part.slots, 2))
1
:
log('W', "", "Slots section in file " .. tostring(sourceFilename) .. " invalid. Please fix. Partly reconstructed: " .. dumpsz(part.slots, 2))
2
:
log_jbeam('E', "", "section invalid: "..tostring(keyEntry) .. ' = ' .. dumpsz(entry, 2))
error(*)
[3]
0
:
error(err, errlevel)
1
:
error(("malformed parameter '%s' to irc command"):format(str), errLevel)
2
:
error("you must require copas before require'ing socket.http")
formatTimeStringNow(res)
[1]
0
:
table.insert(c, '# saved on ' .. formatTimeStringNow('{YYYY}/{MM}/{DD} {HH}:{mm}:{ss}') .. '\r\n')
fsign(x)
[3]
0
:
avDiff = (outputAV2Corrected - outputAV1Corrected) * fsign(inputAV)
1
:
local avDiffCorrected = max(abs(avDiff) - controlParameters.avDiffThreshold, 0) * fsign(avDiff)
2
:
steeringBiasCoef = linearScale(abs(electrics.values.steering), 0.1, 0.3, 0, 1) * fsign(electrics.values.steering) * gForceCoef * throttleCoef
gcinfo(*)
[1]
0
:
local used_mem, _ = gcinfo()
getContrastColor(i, a)
[3]
0
:
local red = color(255,0,0,200) -- getContrastColor(objectId)
1
:
local col = getContrastColor(objectId)
2
:
local c = getContrastColor(groups[v])
getContrastColorStringRGB(i)
[3]
0
:
-- accX = {title = "Acc X", color = getContrastColorStringRGB(1), unit = "", value = o.accX},
1
:
-- accY = {title = "Acc Y", color = getContrastColorStringRGB(2), unit = "", value = o.accY},
2
:
-- accZ = {title = "Acc Z", color = getContrastColorStringRGB(3), unit = "", value = o.accZ}
getfenv(*)
[2]
0
:
local fEnv = getfenv(1) -- we reuse the environment and override only some things ...
1
:
e = V == " 5.1" and getfenv( func ) or _G
getmetatable(*)
[3]
0
:
if (getmetatable(skt) == _skt_mt_tcp) or (getmetatable(skt) == _skt_mt_udp) then
1
:
local mt = getmetatable(server)
2
:
local mt = getmetatable(tbl)
guardZero(x)
[3]
0
:
-- local starterSpentEnergy = 1 / guardZero(abs(device.outputAV1)) * dt * device.starterTorque / 0.5 --0.5 efficiency
1
:
local inputAV = guardZero(device.inputAV)
2
:
local outputAV1 = guardZero(device.outputAV1)
importPersistentData(s)
[1]
0
:
importPersistentData(save.luaState)
init(path, initData)
[2]
0
:
init()
1
:
init()
initSystems()
[1]
0
:
initSystems()
intersectsRay_Plane(rpos, rdir, plpos, pln)
[1]
0
:
local plhita, plhitb = intersectsRay_Plane(rpos, rdir, cposa, cpnorm), intersectsRay_Plane(rpos, rdir, cposb, cpnorm)
intersectsRay_Sphere(rpos, rdir, cpos, cr)
[1]
0
:
local minhit, maxhit = intersectsRay_Sphere(vec3(0,0,0), rdp:normalized(), cp, cR)
ipairs(*)
[3]
0
:
for _, wheel in ipairs(relevantWheels[-1].wheels) do
1
:
for _, wheel in ipairs(relevantWheels[1].wheels) do
2
:
for _, wheel in ipairs(relevantWheels[-1].wheels) do
isinf(a)
[2]
0
:
if isnan(wheelData.toe) or isinf(wheelData.toe) then
1
:
if isnan(wheelData.camber) or isinf(wheelData.camber) then
isnan(a)
[3]
0
:
if isnan(wheelData.toe) or isinf(wheelData.toe) then
1
:
if isnan(wheelData.camber) or isinf(wheelData.camber) then
2
:
if isnan(ballAV) then
isnaninf(a)
[1]
0
:
return isnaninf(number) and 0 or number
jsonDecode(content, context)
[3]
0
:
return jsonDecode(table.concat(respbody), 'json request response')
1
:
local configTable = jsonDecode(controllerConfig, "CMU SetConfig")
2
:
local paramTable = jsonDecode(param, "CMU SetProperty")
jsonEncode(v)
[3]
0
:
local reqbody = "data=" .. jsonEncode(data)
1
:
obj:queueObjectLuaCommand(objID, string.format("%s(%q)", callback, jsonEncode(chassisData)))
2
:
udpSocket:send(jsonEncode(debugPackets))
jsonEncodePretty(v, lvl, numberPrecision)
[3]
0
:
for _, vv in ipairs(v) do table.insert(tmp, jsonEncodePretty(vv, lvl + 1, numberPrecision))
1
:
local cv = jsonEncodePretty(vv, lvl + 1, numberPrecision)
2
:
content = jsonEncodePretty(obj, 1, numberPrecision)
jsonReadFile(filename)
[3]
0
:
local save = jsonReadFile(filename)
1
:
local data = jsonReadFile(filepath)
2
:
local data = jsonReadFile(filename)
jsonWriteFile(filename, obj, pretty, numberPrecision)
[3]
0
:
jsonWriteFile(filename, save, true)
1
:
jsonWriteFile(filepath, data, true)
2
:
jsonWriteFile(filepath, data, true)
lerp(from, to, t)
[3]
0
:
square(ai.width + lerp(p1Radius, plan[i+2].radius, min(1, nextXnorm))) then
1
:
scriptTime = lerp(s1t, s2t, xnorm)
2
:
scriptTime = lerp(s1t, s2t, xnorm)
linePointFromXnorm(p0, p1, xnorm)
[3]
0
:
if aiPos:squaredDistance(linePointFromXnorm(p1Pos, plan[i+2].pos, nextXnorm)) <
1
:
local prevPos = linePointFromXnorm(plan[1].pos, plan[2].pos, aiXnormOnSeg) -- aiPos
2
:
local lp_n1n2 = linePointFromXnorm(prevPos, pos, xnorm * 0.5 + 0.25)
linearScale(v, minValue, maxValue, minOutput, maxOutput)
[3]
0
:
local gForceCoef = linearScale(abs(CMU.sensorHub.accelerationXSmooth), 7, 10, 0, 1)
1
:
local throttleCoef = linearScale(electrics.values.throttle or 0, 0, 0.5, 0, 1)
2
:
steeringBiasCoef = linearScale(abs(electrics.values.steering), 0.1, 0.3, 0, 1) * fsign(electrics.values.steering) * gForceCoef * throttleCoef
load(*)
[3]
0
:
local func, err = load(cmd, source, 't', fEnv)
1
:
local exprFunc, message = load("return "..sanitizedExpr, nil, 't', env)
2
:
load(luaFilename:sub(1,-5)) -- strip '.lua'
loadIni(filename)
[2]
0
:
values = loadIni(persistencyfile)
1
:
local cloudValues = loadIni(persistencyfileCloud)
loadstring(*)
[3]
0
:
if loadstring("return "..funcString.."_freeze_backup")() == nil then
1
:
if loadstring("return "..funcString.."_freeze_backup")() == nil then
2
:
loadstring(funcString.." = "..funcString.."_freeze_backup")() -- restore backup code back to its original place
log()
[3]
0
:
log("E", "adaptiveDampers.setDamperMode", "Can't find mode: " .. modeName)
1
:
log("E", "adaptiveTorsionBars.setTorsionBarMode", "Can't find mode: " .. modeName)
2
:
log('D', "AI", "Could not find a road network, or closest road is too far")
log_jbeam()
[3]
0
:
log_jbeam('W', "", "*** Invalid table header")
1
:
log_jbeam('W', "", "*** Invalid table header, must be a list, not a dict: "..dumps(header))
2
:
log_jbeam('W', "", "*** Invalid table row: "..dumps(rowValue))
lpad(s, l, c)
[2]
0
:
return lpad(result, pad or 0, ' ')
1
:
log("I", "core_performance", " * " .. rpad(t[1], 34, " ") .. " = " .. lpad(string.format("%5.1f", t[4]), 8, " ") .. " ms")
newExponentialSmoothing(window, startingValue)
[3]
0
:
local inputAVSmoother = newExponentialSmoothing(50)
1
:
local outputAV1Smoother = newExponentialSmoothing(50)
2
:
local outputAV2Smoother = newExponentialSmoothing(50)
newLinearSmoothing(dt, inRate, outRate)
[1]
0
:
brakePressureDelay = newLinearSmoothing(physicsDt, (wd.brakeTorque or 0) / ((wd.brakePressureInDelay or 0.05) + 1e-30), (wd.brakeTorque or 0) / ((wd.brakePressureOutDelay or 0.1) + 1e-30)),
newPIDParallel(kP, kI, kD, minOutput, maxOutput, integralInCoef, integralOutCoef, minIntegral, maxIntegral)
[3]
0
:
biasPID = newPIDParallel(controlParameters.brakingPIDkP, controlParameters.brakingPIDkI, controlParameters.brakingPIDkD, -1, 1, 1000, 100)
1
:
lockingPID = newPIDParallel(controlParameters.lockingPIDkP, controlParameters.lockingPIDkI, controlParameters.lockingPIDkD, 0, 1)
2
:
wheelControlData[wheelData.wheel.name].tractionControlBrakingPID = newPIDParallel(kP, kI, kD, 0, 1, integralInCoef, integralOutCoef, 0)
newPIDStandard(kP, tI, tD, minOutput, maxOutput, integralInCoef, integralOutCoef, minIntegral, maxIntegral)
[2]
0
:
--local myPID = newPIDStandard(1, 0.5, 0.1, 0, 1)
1
:
local speedPID = newPIDStandard(0.3, 2, 0.0, 0, 1, 1, 1, 0, 2)
newTemporalSigmoidSmoothing(inRate, startAccel, stopAccel, outRate, startingValue)
[1]
0
:
local rpmSmoother = newTemporalSigmoidSmoothing(50000, 75000, 50000, 75000, 0)
newTemporalSmoothing(inRate, outRate, autoCenterRate, startingValue)
[3]
0
:
absActiveSmoother = newTemporalSmoothing(2, 2)
1
:
escActiveSmoother = newTemporalSmoothing(2, 2)
2
:
local aiDeviationSmoother = newTemporalSmoothing(1)
newTemporalSmoothingNonLinear(inRate, outRate, startingValue)
[3]
0
:
local biasSmoother = newTemporalSmoothingNonLinear(10, 10)
1
:
local lockingSmoother = newTemporalSmoothingNonLinear(10, 10)
2
:
local targetSpeedSmoother = nil -- = newTemporalSmoothingNonLinear(math.huge, 0.2)
newproxy(*)
[3]
0
:
prof_ud = newproxy(true)
1
:
local baseproxy = newproxy(true)
2
:
local pt = newproxy(baseproxy)
next(*)
[3]
0
:
if next(newRoute) == nil then
1
:
if next(edgeDict) == nil then
2
:
if next(couplerCache) == nil then
pairs(*)
[3]
0
:
for _, b in pairs(v.data.beams) do
1
:
for _, name in pairs(dampBeamNames) do
2
:
for _, mode in pairs(modeData) do
pairsByKeys(t, f)
[1]
0
:
for orgMat, gm in pairsByKeys(vehicle.glowMap) do --order not guaranted when reloading GE
parseColor(v)
[2]
0
:
obj.debugDrawProxy:drawNodeSphere(node.cid, node.highlight.radius, parseColor(node.highlight.col))
1
:
if prop.lightColor then color = parseColor(prop.lightColor)
pcall(*)
[3]
0
:
local has_bit32,bit = pcall(require,'bit32')
1
:
local ffifound, ffi = pcall(require, 'ffi')
2
:
local result, errorStr = pcall(loadFunc)
print()
[3]
0
:
-- print(list[i])
1
:
print("### onVehicleScenarioData ###")
2
:
if #planets > 0 then print('obj:setPlanets(' .. dumps(planets) .. ')')
processResponseCurve(rCurve)
[1]
0
:
responseCurve = processResponseCurve(responseCurve)
profilerPopEvent()
[3]
0
:
profilerPopEvent() -- jbeam/assorted.process
1
:
profilerPopEvent() -- jbeam/camera.process
2
:
profilerPopEvent()
profilerPushEvent()
[3]
0
:
profilerPushEvent('jbeam/assorted.process')
1
:
profilerPushEvent('jbeam/camera.process')
2
:
profilerPushEvent('processEvents')
quat(x, y, z, w)
[3]
0
:
local pos = (quat(obj:getRotation()) * imu.pos + vec3(obj:getPosition())):toFloat3()
1
:
return quat(x, y, z, w), c, seridx
2
:
local cameraRotation = quat(0, 0, 0, 0)
quatFromAxisAngle(axle, angleRad)
[3]
0
:
local rayRot = quatFromAxisAngle(axis, 2 * math.pi / (wheel.numRays* 2))
1
:
local rayRot = quatFromAxisAngle(axis, 2 * math.pi / (wheel.numRays* 2))
2
:
local tmpRot = quatFromAxisAngle(axis, 2 * math.pi / (wheel.numRays * 4))
quatFromDir(dir, up)
[3]
0
:
local q = quatFromDir(n)
1
:
local quat = quatFromDir(vectorForward, upVector)
2
:
local rot = quatFromDir(dirFront, dirUp)
rainbowColor(numOfSteps, step, format)
[3]
0
:
local c = rainbowColor(16, i % 17)
1
:
local c = rainbowColor(16, i % 17, 255)
2
:
local c = rainbowColor(16, i % 17, 255)
randomGauss3()
[3]
0
:
heatTickData.exhaustTickBucketThreshold = 0.1 * linearScale(randomGauss3(), 0, 3, 0.5, 1.5)
1
:
heatTickData.engineTickBucketThreshold = 0.04 * linearScale(randomGauss3(), 0, 3, 0.5, 1.5)
2
:
rigidRollVolume = min(1, max(absWheelSpeed, min(slip, groundSpeed)) * 0.025) * (randomGauss3() * 0.33 + 0.5) * cobbleStoneContactSmooth
rawget(*)
[3]
0
:
return rawget(tbl, key)
1
:
local m = rawget(M, extName)
2
:
local m = rawget(M, extName)
rawset(*)
[3]
0
:
rawset(_G, extName, nil)
1
:
rawset(_G, extName, m) -- rawset avoids global setter wrapper detections
2
:
return rawset(self, key, value)
readDictJSONTable(filename)
[2]
0
:
local mix = readDictJSONTable("lua/common/particles.json")
1
:
local tmp = readDictJSONTable(sbfn)
readFile(filename)
[3]
0
:
ffi.cdef(readFile('lua/common/extensions/ui/imgui_gen.h'))
1
:
local content = readFile(filename)
2
:
body = readFile(fn)
require(*)
[3]
0
:
scriptai = require("scriptai")
1
:
scriptai = require("scriptai")
2
:
scriptai = require("scriptai")
require_optional(module)
[3]
0
:
local jbeamPartColors = require_optional('jbeam/sections/partColors') or { process=nop }
1
:
local jbeamCondition = require_optional('jbeam/sections/condition') or { process=nop }
2
:
ffi = require_optional('ffi') -- this sets the global ffi variable
rerequire(module)
[2]
0
:
local controller = rerequire(filePath)
1
:
cmd = 'rerequire("lua/vehicle/beamng") ; rerequire("lua/tests/test")'
round(a)
[3]
0
:
["0-100 km/h"] = time100kmh and (round(time100kmh * 10) / 10) or nil,
1
:
["0-200 km/h"] = time200kmh and (round(time200kmh * 10) / 10) or nil,
2
:
["0-300 km/h"] = time300kmh and (round(time300kmh * 10) / 10) or nil,
rpad(s, l, c)
[2]
0
:
--local msg = rpad(title, width, " ").." = "..format(time, 3, 8)
1
:
log("I", "core_performance", " * " .. rpad(t[1], 34, " ") .. " = " .. lpad(string.format("%5.1f", t[4]), 8, " ") .. " ms")
saveCompiledJBeamRecursive(f, data, level)
[3]
0
:
saveCompiledJBeamRecursive(f, v, level + 1)
1
:
saveCompiledJBeamRecursive(f, v, level + 1)
2
:
saveCompiledJBeamRecursive(f, data, lvl or 0)
select(*)
[3]
0
:
if select("#", ...) > 0 then
1
:
pcall(finalizer, select(2, ...))
2
:
error({ (select(2, ...)) }, 0)
serialize(v)
[3]
0
:
obj:queueGameEngineLua(string.format("onObjectCouplingChange(%s,%s)", objectId, serialize(attachedCouplers)))
1
:
obj:queueObjectLuaCommand(obj2id, "beamstate.exportCouplerData(" .. tostring(obj2nodeId) .. ", " .. serialize(data) .. ")")
2
:
obj:queueObjectLuaCommand(coupler.obj2id, string.format("beamstate.importCouplerData(%s, %s)", coupler.obj2nodeId, serialize(data)))
serializePackages(reason)
[2]
0
:
save.luaState = serialize(serializePackages("save"))
1
:
local d = serializePackages("reload")
setfenv(*)
[3]
0
:
setfenv( func, env )
1
:
setfenv(func, setmetatable({ template = template }, context))
2
:
setfenv(fn, tempG)
setmetatable(*)
[3]
0
:
setmetatable(M, backwardCompatibility)
1
:
return setmetatable({ r = r, g = g, b = b, a = a }, LuaColor)
2
:
setmetatable(data, PIDParallel)
shallowcopy(orig)
[3]
0
:
local data = shallowcopy(n)
1
:
couplerBreakGroupCacheOrig = shallowcopy(couplerBreakGroupCache)
2
:
local beams = shallowcopy(currentExhaustBeams)
sign(x)
[3]
0
:
local outDeviation = aiDeviationSmoother:value() - aiDeviation * sign(tp2)
1
:
outDeviation = sign(outDeviation) * min(1, abs(outDeviation))
2
:
lane = sign((mapData.positions[path[curPathIdx]] - p1Pos):z0():cross(gravityDir):dot(p1Pos - aiPos))
sign2(x)
[3]
0
:
local pbrake = clamp(sign2(aiDirVec:dot(gravityDir) - 0.17), 0, 1) -- apply parking brake if reversing on an incline >~ 10 deg
1
:
--plAccel = plAccel + sign2(plAccel) * 1e-5
2
:
trafficSide.side = sign2(trafficSide.timerRange - trafficSide.timer)
split(str, delim, nMax)
[3]
0
:
local split = split(partType, ":")
1
:
local split = split(partType, ":")
2
:
local splits = split(data, "->")
square(a)
[3]
0
:
brakeCoef = brakeCoef * square(max(0, absAiSpeed - totalSlip) / absAiSpeed)
1
:
square(ai.width + lerp(p1Radius, plan[i+2].radius, min(1, nextXnorm))) then
2
:
local brakeDist = square(aiSpeed) / (2 * g * aggression)
stringHash(text)
[2]
0
:
obj.debugDrawProxy:drawNodeSphere(coupler.cid, 0.15, getContrastColor(stringHash(coupler.couplerTag or coupler.tag), 150))
1
:
obj.debugDrawProxy:drawNodeSphere(coupler.cid, 0.15, getContrastColor(stringHash(coupler.couplerTag or coupler.tag), 150))
tableContains(t, element)
[3]
0
:
if not tableContains(exceptionList, moduleName) then
1
:
if tableContains(partSlotMap[dir][part.slotType], partName) then
2
:
if part.licenseplateFormat and not tableContains(licensePlateUsedFormats,part.licenseplateFormat) then
tableDepth(tbl, lookup)
[2]
0
:
lookup[k] = lookup[k] or tableDepth(k, lookup)
1
:
lookup[v] = lookup[v] or tableDepth(v, lookup)
tableFindKey(t, element)
[1]
0
:
if tableFindKey(t, element) == nil then return false return true
tableFromHeaderTable(entry)
[3]
0
:
local modeData = tableFromHeaderTable(jbeamData.modes or {})
1
:
local modeData = tableFromHeaderTable(jbeamData.modes or {})
2
:
local wheelGroupSettings = tableFromHeaderTable(jbeamData.tractionControl.wheelGroupSettings or {})
tableIsDict(tbl)
[3]
0
:
if type(entry) == "table" and tableIsDict(entry) and jbeamUtils.ignoreSections[keyEntry] == nil and tableIsDict(entry[0]) and entry[0]['disableSection'] ~= nil then
1
:
if type(entry) == "table" and tableIsDict(entry) and not jbeamUtils.ignoreSections[keyEntry] then
2
:
if type(section) == "table" and not tableIsDict(section) then
tableIsEmpty(tbl)
[3]
0
:
if not tableIsEmpty(toResolveModules) then
1
:
if not tableIsEmpty(toPrint) then
2
:
if not tableIsEmpty(failedModules) then
tableKeys(tbl)
[2]
0
:
local sortedNodeKeys = tableKeys(nodes)
1
:
local tableKeys = tableKeys(v)
tableMerge(dst, src)
[3]
0
:
tableMerge(M, newMode)
1
:
tableMerge(M, newState)
2
:
tableMerge(electrics.values, recievedElectrics[i])
tableMergeRecursive(t1, t2)
[3]
0
:
local data = tableMergeRecursive(c, v.data[k] or {})
1
:
tableMergeRecursive(jbeamData, v.data[jbeamData.name] or {})
2
:
escConfigs = tableMergeRecursive(escConfigs, v.userSettings.escConfig)
tableReadOnly(table)
[1]
0
:
env = tableReadOnly(env)
tableSize(tbl)
[3]
0
:
elseif tableSize(mapmgr.objects) == 2 then
1
:
if tableSize(mapData.graph[nid1]) > 2 then
2
:
for i = 0, tableSize(forwardGears) - 1, 1 do
tableSizeC(tbl)
[3]
0
:
for i = 0, tableSizeC(lwheels) - 1 do
1
:
statusTxt = statusTxt .. '#beams: ' .. tostring(tableSizeC(v.data.beams)) .. ' | '
2
:
for i = 0, tableSizeC(v.data.beams) - 1 do
tonumber(*)
[3]
0
:
cid = tonumber(cid) - 1
1
:
cid = tonumber(cid) - 1
2
:
return tonumber(gsub(s, '.', radixmark))
tostring(*)
[3]
0
:
--print('body:' .. tostring(body))
1
:
--print('code:' .. tostring(code))
2
:
--print('status:' .. tostring(status))
trim(s)
[3]
0
:
local key = string.lower(trim(args[1]))
1
:
local value = trim(args[2])
2
:
flexmeshMats[flexbody.mesh] = split(trim(matNamesStr), " ")
type(*)
[3]
0
:
(type(arg.wpTargetList) ~= 'table' and type(arg.path) ~= 'table' and type(arg.script) ~= 'table') or
1
:
(arg.wpSpeeds ~= nil and type(arg.wpSpeeds) ~= 'table') or
2
:
(arg.noOfLaps ~= nil and type(arg.noOfLaps) ~= 'number') or
ui_message(msg, ttl, category, icon)
[1]
0
:
ui_message("Boooooost!", 5, 'boost')
unpack(*)
[3]
0
:
local dataRow = string.format(rowFmt, unpack(dataRow))
1
:
return getVarByNameInScope({select(2, unpack(components))}, scope[components[1]])
2
:
return {dt, unpack(res)}
updateCorePhysicsStepEnabled()
[3]
0
:
updateCorePhysicsStepEnabled()
1
:
updateCorePhysicsStepEnabled()
2
:
updateCorePhysicsStepEnabled()
vec3(x, y, z)
[3]
0
:
--local cog = vec3(obj:calcCenterOfGravityRel(true)) + obj:getPosition()
1
:
local copVec = vec3(obj:calcCenterOfPressureRel() + obj:getPosition())
2
:
aeroData.totalAeroForce = vec3(obj:calcTotalAeroForces())
writeFile(filename, data)
[2]
0
:
writeFile(filename, txt)
1
:
writeFile(fileName, data)
xpcall(*)
[3]
0
:
local ok, result = xpcall(func, debug.traceback)
1
:
local ok, result = xpcall(func, debug.traceback)
2
:
xpcall(